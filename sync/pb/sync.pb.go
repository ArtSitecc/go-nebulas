// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sync.proto

package syncpb

import (
	fmt "fmt"
	pb "github.com/nebulasio/go-nebulas/core/pb"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type Sync struct {
	TailBlockHash []byte `protobuf:"bytes,1,opt,name=tail_block_hash,json=tailBlockHash,proto3" json:"tail_block_hash,omitempty"`
}

func (m *Sync) Reset() { *m = Sync{} }
func (m *Sync) String() string {
	if b, err := m.Marshal(); err == nil {
		return string(b)
	}
	return string("")
}
func (*Sync) ProtoMessage() {}

func (m *Sync) GetTailBlockHash() []byte {
	if m != nil {
		return m.TailBlockHash
	}
	return nil
}

type ChunkHeader struct {
	Headers [][]byte `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty"`
	Root    []byte   `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *ChunkHeader) Reset() { *m = ChunkHeader{} }
func (m *ChunkHeader) String() string {
	if b, err := m.Marshal(); err == nil {
		return string(b)
	}
	return string("")
}
func (*ChunkHeader) ProtoMessage() {}

func (m *ChunkHeader) GetHeaders() [][]byte {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *ChunkHeader) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

type ChunkHeaders struct {
	ChunkHeaders []*ChunkHeader `protobuf:"bytes,1,rep,name=chunkHeaders,proto3" json:"chunkHeaders,omitempty"`
	Root         []byte         `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *ChunkHeaders) Reset() { *m = ChunkHeaders{} }
func (m *ChunkHeaders) String() string {
	if b, err := m.Marshal(); err == nil {
		return string(b)
	}
	return string("")
}
func (*ChunkHeaders) ProtoMessage() {}

func (m *ChunkHeaders) GetChunkHeaders() []*ChunkHeader {
	if m != nil {
		return m.ChunkHeaders
	}
	return nil
}

func (m *ChunkHeaders) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

type ChunkData struct {
	Blocks []*pb.Block `protobuf:"bytes,1,rep,name=blocks,proto3" json:"blocks,omitempty"`
	Root   []byte      `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *ChunkData) Reset() { *m = ChunkData{} }
func (m *ChunkData) String() string {
	if b, err := m.Marshal(); err == nil {
		return string(b)
	}
	return string("")
}
func (*ChunkData) ProtoMessage() {}

func (m *ChunkData) GetBlocks() []*pb.Block {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *ChunkData) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *Sync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sync) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TailBlockHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSync(dAtA, i, uint64(len(m.TailBlockHash)))
		i += copy(dAtA[i:], m.TailBlockHash)
	}
	return i, nil
}

func (m *ChunkHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for _, b := range m.Headers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSync(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Root) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSync(dAtA, i, uint64(len(m.Root)))
		i += copy(dAtA[i:], m.Root)
	}
	return i, nil
}

func (m *ChunkHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkHeaders) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChunkHeaders) > 0 {
		for _, msg := range m.ChunkHeaders {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSync(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Root) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSync(dAtA, i, uint64(len(m.Root)))
		i += copy(dAtA[i:], m.Root)
	}
	return i, nil
}

func (m *ChunkData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSync(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Root) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSync(dAtA, i, uint64(len(m.Root)))
		i += copy(dAtA[i:], m.Root)
	}
	return i, nil
}

func encodeVarintSync(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Sync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TailBlockHash)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *ChunkHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for _, b := range m.Headers {
			l = len(b)
			n += 1 + l + sovSync(uint64(l))
		}
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *ChunkHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChunkHeaders) > 0 {
		for _, e := range m.ChunkHeaders {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *ChunkData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func sovSync(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSync(x uint64) (n int) {
	return sovSync(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Sync) Unmarshal(dAtA []byte) error {
	l := uint32(len(dAtA))
	iNdEx := uint32(0)
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := uint32(wire >> 3)
		wireType := uint32(wire & 0x7)
		_ = wireType
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TailBlockHash", wireType)
			}
			var byteLen uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TailBlockHash = append(m.TailBlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TailBlockHash == nil {
				m.TailBlockHash = []byte{}
			}
			iNdEx = postIndex
		default:
			return fmt.Errorf("proto: invalid data ")
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkHeader) Unmarshal(dAtA []byte) error {
	l := uint32(len(dAtA))
	iNdEx := uint32(0)
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := uint32(wire >> 3)
		wireType := uint32(wire & 0x7)
		_ = wireType
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var byteLen uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, make([]byte, postIndex-iNdEx))
			copy(m.Headers[len(m.Headers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			return fmt.Errorf("proto: invalid data ")
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkHeaders) Unmarshal(dAtA []byte) error {
	l := uint32(len(dAtA))
	iNdEx := uint32(0)
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := uint32(wire >> 3)
		wireType := uint32(wire & 0x7)
		_ = wireType
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkHeaders", wireType)
			}
			var msglen uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChunkHeaders = append(m.ChunkHeaders, &ChunkHeader{})
			if err := m.ChunkHeaders[len(m.ChunkHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			return fmt.Errorf("proto: invalid data ")
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkData) Unmarshal(dAtA []byte) error {
	l := uint32(len(dAtA))
	iNdEx := uint32(0)
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := uint32(wire >> 3)
		wireType := uint32(wire & 0x7)
		_ = wireType
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &pb.Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			return fmt.Errorf("proto: invalid data ")
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

var (
	ErrInvalidLengthSync = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSync   = fmt.Errorf("proto: integer overflow")
)
