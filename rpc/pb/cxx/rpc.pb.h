// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

#ifndef PROTOBUF_rpc_2eproto__INCLUDED
#define PROTOBUF_rpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "github.com/nebulasio/go-nebulas/consensus/pb/state.pb.h"
#include "github.com/nebulasio/go-nebulas/core/pb/block.pb.h"
#include "github.com/nebulasio/go-nebulas/neblet/pb/config.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_rpc_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[46];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsSubscribeRequestImpl();
void InitDefaultsSubscribeRequest();
void InitDefaultsSubscribeResponseImpl();
void InitDefaultsSubscribeResponse();
void InitDefaultsNonParamsRequestImpl();
void InitDefaultsNonParamsRequest();
void InitDefaultsNodeInfoResponseImpl();
void InitDefaultsNodeInfoResponse();
void InitDefaultsRouteTableImpl();
void InitDefaultsRouteTable();
void InitDefaultsGetNebStateResponseImpl();
void InitDefaultsGetNebStateResponse();
void InitDefaultsAccountsResponseImpl();
void InitDefaultsAccountsResponse();
void InitDefaultsGetAccountStateRequestImpl();
void InitDefaultsGetAccountStateRequest();
void InitDefaultsGetAccountStateResponseImpl();
void InitDefaultsGetAccountStateResponse();
void InitDefaultsCallResponseImpl();
void InitDefaultsCallResponse();
void InitDefaultsByBlockHeightRequestImpl();
void InitDefaultsByBlockHeightRequest();
void InitDefaultsGetDynastyResponseImpl();
void InitDefaultsGetDynastyResponse();
void InitDefaultsTransactionRequestImpl();
void InitDefaultsTransactionRequest();
void InitDefaultsContractRequestImpl();
void InitDefaultsContractRequest();
void InitDefaultsSendRawTransactionRequestImpl();
void InitDefaultsSendRawTransactionRequest();
void InitDefaultsSendTransactionResponseImpl();
void InitDefaultsSendTransactionResponse();
void InitDefaultsGetBlockByHashRequestImpl();
void InitDefaultsGetBlockByHashRequest();
void InitDefaultsGetBlockByHeightRequestImpl();
void InitDefaultsGetBlockByHeightRequest();
void InitDefaultsGetTransactionByHashRequestImpl();
void InitDefaultsGetTransactionByHashRequest();
void InitDefaultsGetTransactionByContractRequestImpl();
void InitDefaultsGetTransactionByContractRequest();
void InitDefaultsBlockResponseImpl();
void InitDefaultsBlockResponse();
void InitDefaultsTransactionResponseImpl();
void InitDefaultsTransactionResponse();
void InitDefaultsNewAccountRequestImpl();
void InitDefaultsNewAccountRequest();
void InitDefaultsNewAccountResponseImpl();
void InitDefaultsNewAccountResponse();
void InitDefaultsUnlockAccountRequestImpl();
void InitDefaultsUnlockAccountRequest();
void InitDefaultsUnlockAccountResponseImpl();
void InitDefaultsUnlockAccountResponse();
void InitDefaultsLockAccountRequestImpl();
void InitDefaultsLockAccountRequest();
void InitDefaultsLockAccountResponseImpl();
void InitDefaultsLockAccountResponse();
void InitDefaultsSignHashRequestImpl();
void InitDefaultsSignHashRequest();
void InitDefaultsSignHashResponseImpl();
void InitDefaultsSignHashResponse();
void InitDefaultsGenerateRandomSeedRequestImpl();
void InitDefaultsGenerateRandomSeedRequest();
void InitDefaultsGenerateRandomSeedResponseImpl();
void InitDefaultsGenerateRandomSeedResponse();
void InitDefaultsSignTransactionPassphraseRequestImpl();
void InitDefaultsSignTransactionPassphraseRequest();
void InitDefaultsSignTransactionPassphraseResponseImpl();
void InitDefaultsSignTransactionPassphraseResponse();
void InitDefaultsSendTransactionPassphraseRequestImpl();
void InitDefaultsSendTransactionPassphraseRequest();
void InitDefaultsGasPriceResponseImpl();
void InitDefaultsGasPriceResponse();
void InitDefaultsHashRequestImpl();
void InitDefaultsHashRequest();
void InitDefaultsGasResponseImpl();
void InitDefaultsGasResponse();
void InitDefaultsEventsResponseImpl();
void InitDefaultsEventsResponse();
void InitDefaultsEventImpl();
void InitDefaultsEvent();
void InitDefaultsPprofRequestImpl();
void InitDefaultsPprofRequest();
void InitDefaultsPprofResponseImpl();
void InitDefaultsPprofResponse();
void InitDefaultsGetConfigResponseImpl();
void InitDefaultsGetConfigResponse();
void InitDefaultsNVMDeployRequestImpl();
void InitDefaultsNVMDeployRequest();
void InitDefaultsNVMDataRequestImpl();
void InitDefaultsNVMDataRequest();
void InitDefaultsNVMResponseImpl();
void InitDefaultsNVMResponse();
inline void InitDefaults() {
  InitDefaultsSubscribeRequest();
  InitDefaultsSubscribeResponse();
  InitDefaultsNonParamsRequest();
  InitDefaultsNodeInfoResponse();
  InitDefaultsRouteTable();
  InitDefaultsGetNebStateResponse();
  InitDefaultsAccountsResponse();
  InitDefaultsGetAccountStateRequest();
  InitDefaultsGetAccountStateResponse();
  InitDefaultsCallResponse();
  InitDefaultsByBlockHeightRequest();
  InitDefaultsGetDynastyResponse();
  InitDefaultsTransactionRequest();
  InitDefaultsContractRequest();
  InitDefaultsSendRawTransactionRequest();
  InitDefaultsSendTransactionResponse();
  InitDefaultsGetBlockByHashRequest();
  InitDefaultsGetBlockByHeightRequest();
  InitDefaultsGetTransactionByHashRequest();
  InitDefaultsGetTransactionByContractRequest();
  InitDefaultsBlockResponse();
  InitDefaultsTransactionResponse();
  InitDefaultsNewAccountRequest();
  InitDefaultsNewAccountResponse();
  InitDefaultsUnlockAccountRequest();
  InitDefaultsUnlockAccountResponse();
  InitDefaultsLockAccountRequest();
  InitDefaultsLockAccountResponse();
  InitDefaultsSignHashRequest();
  InitDefaultsSignHashResponse();
  InitDefaultsGenerateRandomSeedRequest();
  InitDefaultsGenerateRandomSeedResponse();
  InitDefaultsSignTransactionPassphraseRequest();
  InitDefaultsSignTransactionPassphraseResponse();
  InitDefaultsSendTransactionPassphraseRequest();
  InitDefaultsGasPriceResponse();
  InitDefaultsHashRequest();
  InitDefaultsGasResponse();
  InitDefaultsEventsResponse();
  InitDefaultsEvent();
  InitDefaultsPprofRequest();
  InitDefaultsPprofResponse();
  InitDefaultsGetConfigResponse();
  InitDefaultsNVMDeployRequest();
  InitDefaultsNVMDataRequest();
  InitDefaultsNVMResponse();
}
}  // namespace protobuf_rpc_2eproto
namespace rpcpb {
class AccountsResponse;
class AccountsResponseDefaultTypeInternal;
extern AccountsResponseDefaultTypeInternal _AccountsResponse_default_instance_;
class BlockResponse;
class BlockResponseDefaultTypeInternal;
extern BlockResponseDefaultTypeInternal _BlockResponse_default_instance_;
class ByBlockHeightRequest;
class ByBlockHeightRequestDefaultTypeInternal;
extern ByBlockHeightRequestDefaultTypeInternal _ByBlockHeightRequest_default_instance_;
class CallResponse;
class CallResponseDefaultTypeInternal;
extern CallResponseDefaultTypeInternal _CallResponse_default_instance_;
class ContractRequest;
class ContractRequestDefaultTypeInternal;
extern ContractRequestDefaultTypeInternal _ContractRequest_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventsResponse;
class EventsResponseDefaultTypeInternal;
extern EventsResponseDefaultTypeInternal _EventsResponse_default_instance_;
class GasPriceResponse;
class GasPriceResponseDefaultTypeInternal;
extern GasPriceResponseDefaultTypeInternal _GasPriceResponse_default_instance_;
class GasResponse;
class GasResponseDefaultTypeInternal;
extern GasResponseDefaultTypeInternal _GasResponse_default_instance_;
class GenerateRandomSeedRequest;
class GenerateRandomSeedRequestDefaultTypeInternal;
extern GenerateRandomSeedRequestDefaultTypeInternal _GenerateRandomSeedRequest_default_instance_;
class GenerateRandomSeedResponse;
class GenerateRandomSeedResponseDefaultTypeInternal;
extern GenerateRandomSeedResponseDefaultTypeInternal _GenerateRandomSeedResponse_default_instance_;
class GetAccountStateRequest;
class GetAccountStateRequestDefaultTypeInternal;
extern GetAccountStateRequestDefaultTypeInternal _GetAccountStateRequest_default_instance_;
class GetAccountStateResponse;
class GetAccountStateResponseDefaultTypeInternal;
extern GetAccountStateResponseDefaultTypeInternal _GetAccountStateResponse_default_instance_;
class GetBlockByHashRequest;
class GetBlockByHashRequestDefaultTypeInternal;
extern GetBlockByHashRequestDefaultTypeInternal _GetBlockByHashRequest_default_instance_;
class GetBlockByHeightRequest;
class GetBlockByHeightRequestDefaultTypeInternal;
extern GetBlockByHeightRequestDefaultTypeInternal _GetBlockByHeightRequest_default_instance_;
class GetConfigResponse;
class GetConfigResponseDefaultTypeInternal;
extern GetConfigResponseDefaultTypeInternal _GetConfigResponse_default_instance_;
class GetDynastyResponse;
class GetDynastyResponseDefaultTypeInternal;
extern GetDynastyResponseDefaultTypeInternal _GetDynastyResponse_default_instance_;
class GetNebStateResponse;
class GetNebStateResponseDefaultTypeInternal;
extern GetNebStateResponseDefaultTypeInternal _GetNebStateResponse_default_instance_;
class GetTransactionByContractRequest;
class GetTransactionByContractRequestDefaultTypeInternal;
extern GetTransactionByContractRequestDefaultTypeInternal _GetTransactionByContractRequest_default_instance_;
class GetTransactionByHashRequest;
class GetTransactionByHashRequestDefaultTypeInternal;
extern GetTransactionByHashRequestDefaultTypeInternal _GetTransactionByHashRequest_default_instance_;
class HashRequest;
class HashRequestDefaultTypeInternal;
extern HashRequestDefaultTypeInternal _HashRequest_default_instance_;
class LockAccountRequest;
class LockAccountRequestDefaultTypeInternal;
extern LockAccountRequestDefaultTypeInternal _LockAccountRequest_default_instance_;
class LockAccountResponse;
class LockAccountResponseDefaultTypeInternal;
extern LockAccountResponseDefaultTypeInternal _LockAccountResponse_default_instance_;
class NVMDataRequest;
class NVMDataRequestDefaultTypeInternal;
extern NVMDataRequestDefaultTypeInternal _NVMDataRequest_default_instance_;
class NVMDeployRequest;
class NVMDeployRequestDefaultTypeInternal;
extern NVMDeployRequestDefaultTypeInternal _NVMDeployRequest_default_instance_;
class NVMResponse;
class NVMResponseDefaultTypeInternal;
extern NVMResponseDefaultTypeInternal _NVMResponse_default_instance_;
class NewAccountRequest;
class NewAccountRequestDefaultTypeInternal;
extern NewAccountRequestDefaultTypeInternal _NewAccountRequest_default_instance_;
class NewAccountResponse;
class NewAccountResponseDefaultTypeInternal;
extern NewAccountResponseDefaultTypeInternal _NewAccountResponse_default_instance_;
class NodeInfoResponse;
class NodeInfoResponseDefaultTypeInternal;
extern NodeInfoResponseDefaultTypeInternal _NodeInfoResponse_default_instance_;
class NonParamsRequest;
class NonParamsRequestDefaultTypeInternal;
extern NonParamsRequestDefaultTypeInternal _NonParamsRequest_default_instance_;
class PprofRequest;
class PprofRequestDefaultTypeInternal;
extern PprofRequestDefaultTypeInternal _PprofRequest_default_instance_;
class PprofResponse;
class PprofResponseDefaultTypeInternal;
extern PprofResponseDefaultTypeInternal _PprofResponse_default_instance_;
class RouteTable;
class RouteTableDefaultTypeInternal;
extern RouteTableDefaultTypeInternal _RouteTable_default_instance_;
class SendRawTransactionRequest;
class SendRawTransactionRequestDefaultTypeInternal;
extern SendRawTransactionRequestDefaultTypeInternal _SendRawTransactionRequest_default_instance_;
class SendTransactionPassphraseRequest;
class SendTransactionPassphraseRequestDefaultTypeInternal;
extern SendTransactionPassphraseRequestDefaultTypeInternal _SendTransactionPassphraseRequest_default_instance_;
class SendTransactionResponse;
class SendTransactionResponseDefaultTypeInternal;
extern SendTransactionResponseDefaultTypeInternal _SendTransactionResponse_default_instance_;
class SignHashRequest;
class SignHashRequestDefaultTypeInternal;
extern SignHashRequestDefaultTypeInternal _SignHashRequest_default_instance_;
class SignHashResponse;
class SignHashResponseDefaultTypeInternal;
extern SignHashResponseDefaultTypeInternal _SignHashResponse_default_instance_;
class SignTransactionPassphraseRequest;
class SignTransactionPassphraseRequestDefaultTypeInternal;
extern SignTransactionPassphraseRequestDefaultTypeInternal _SignTransactionPassphraseRequest_default_instance_;
class SignTransactionPassphraseResponse;
class SignTransactionPassphraseResponseDefaultTypeInternal;
extern SignTransactionPassphraseResponseDefaultTypeInternal _SignTransactionPassphraseResponse_default_instance_;
class SubscribeRequest;
class SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
class SubscribeResponse;
class SubscribeResponseDefaultTypeInternal;
extern SubscribeResponseDefaultTypeInternal _SubscribeResponse_default_instance_;
class TransactionRequest;
class TransactionRequestDefaultTypeInternal;
extern TransactionRequestDefaultTypeInternal _TransactionRequest_default_instance_;
class TransactionResponse;
class TransactionResponseDefaultTypeInternal;
extern TransactionResponseDefaultTypeInternal _TransactionResponse_default_instance_;
class UnlockAccountRequest;
class UnlockAccountRequestDefaultTypeInternal;
extern UnlockAccountRequestDefaultTypeInternal _UnlockAccountRequest_default_instance_;
class UnlockAccountResponse;
class UnlockAccountResponseDefaultTypeInternal;
extern UnlockAccountResponseDefaultTypeInternal _UnlockAccountResponse_default_instance_;
}  // namespace rpcpb
namespace rpcpb {

// ===================================================================

class SubscribeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.SubscribeRequest) */ {
 public:
  SubscribeRequest();
  virtual ~SubscribeRequest();

  SubscribeRequest(const SubscribeRequest& from);

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SubscribeRequest* other);
  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscribeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SubscribeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubscribeRequest& from);
  void MergeFrom(const SubscribeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubscribeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topics = 1;
  int topics_size() const;
  void clear_topics();
  static const int kTopicsFieldNumber = 1;
  const ::std::string& topics(int index) const;
  ::std::string* mutable_topics(int index);
  void set_topics(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topics(int index, ::std::string&& value);
  #endif
  void set_topics(int index, const char* value);
  void set_topics(int index, const char* value, size_t size);
  ::std::string* add_topics();
  void add_topics(const ::std::string& value);
  #if LANG_CXX11
  void add_topics(::std::string&& value);
  #endif
  void add_topics(const char* value);
  void add_topics(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& topics() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topics();

  // @@protoc_insertion_point(class_scope:rpcpb.SubscribeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topics_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsSubscribeRequestImpl();
};
// -------------------------------------------------------------------

class SubscribeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.SubscribeResponse) */ {
 public:
  SubscribeResponse();
  virtual ~SubscribeResponse();

  SubscribeResponse(const SubscribeResponse& from);

  inline SubscribeResponse& operator=(const SubscribeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscribeResponse(SubscribeResponse&& from) noexcept
    : SubscribeResponse() {
    *this = ::std::move(from);
  }

  inline SubscribeResponse& operator=(SubscribeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeResponse* internal_default_instance() {
    return reinterpret_cast<const SubscribeResponse*>(
               &_SubscribeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SubscribeResponse* other);
  friend void swap(SubscribeResponse& a, SubscribeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscribeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SubscribeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubscribeResponse& from);
  void MergeFrom(const SubscribeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubscribeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string topic = 1;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // string data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:rpcpb.SubscribeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsSubscribeResponseImpl();
};
// -------------------------------------------------------------------

class NonParamsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.NonParamsRequest) */ {
 public:
  NonParamsRequest();
  virtual ~NonParamsRequest();

  NonParamsRequest(const NonParamsRequest& from);

  inline NonParamsRequest& operator=(const NonParamsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NonParamsRequest(NonParamsRequest&& from) noexcept
    : NonParamsRequest() {
    *this = ::std::move(from);
  }

  inline NonParamsRequest& operator=(NonParamsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NonParamsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NonParamsRequest* internal_default_instance() {
    return reinterpret_cast<const NonParamsRequest*>(
               &_NonParamsRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NonParamsRequest* other);
  friend void swap(NonParamsRequest& a, NonParamsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NonParamsRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NonParamsRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NonParamsRequest& from);
  void MergeFrom(const NonParamsRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NonParamsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rpcpb.NonParamsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsNonParamsRequestImpl();
};
// -------------------------------------------------------------------

class NodeInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.NodeInfoResponse) */ {
 public:
  NodeInfoResponse();
  virtual ~NodeInfoResponse();

  NodeInfoResponse(const NodeInfoResponse& from);

  inline NodeInfoResponse& operator=(const NodeInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeInfoResponse(NodeInfoResponse&& from) noexcept
    : NodeInfoResponse() {
    *this = ::std::move(from);
  }

  inline NodeInfoResponse& operator=(NodeInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfoResponse* internal_default_instance() {
    return reinterpret_cast<const NodeInfoResponse*>(
               &_NodeInfoResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NodeInfoResponse* other);
  friend void swap(NodeInfoResponse& a, NodeInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeInfoResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeInfoResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeInfoResponse& from);
  void MergeFrom(const NodeInfoResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rpcpb.RouteTable route_table = 11;
  int route_table_size() const;
  void clear_route_table();
  static const int kRouteTableFieldNumber = 11;
  const ::rpcpb::RouteTable& route_table(int index) const;
  ::rpcpb::RouteTable* mutable_route_table(int index);
  ::rpcpb::RouteTable* add_route_table();
  ::google::protobuf::RepeatedPtrField< ::rpcpb::RouteTable >*
      mutable_route_table();
  const ::google::protobuf::RepeatedPtrField< ::rpcpb::RouteTable >&
      route_table() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string coinbase = 3;
  void clear_coinbase();
  static const int kCoinbaseFieldNumber = 3;
  const ::std::string& coinbase() const;
  void set_coinbase(const ::std::string& value);
  #if LANG_CXX11
  void set_coinbase(::std::string&& value);
  #endif
  void set_coinbase(const char* value);
  void set_coinbase(const char* value, size_t size);
  ::std::string* mutable_coinbase();
  ::std::string* release_coinbase();
  void set_allocated_coinbase(::std::string* coinbase);

  // string protocol_version = 10;
  void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 10;
  const ::std::string& protocol_version() const;
  void set_protocol_version(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_version(::std::string&& value);
  #endif
  void set_protocol_version(const char* value);
  void set_protocol_version(const char* value, size_t size);
  ::std::string* mutable_protocol_version();
  ::std::string* release_protocol_version();
  void set_allocated_protocol_version(::std::string* protocol_version);

  // uint32 chain_id = 2;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 2;
  ::google::protobuf::uint32 chain_id() const;
  void set_chain_id(::google::protobuf::uint32 value);

  // uint32 peer_count = 4;
  void clear_peer_count();
  static const int kPeerCountFieldNumber = 4;
  ::google::protobuf::uint32 peer_count() const;
  void set_peer_count(::google::protobuf::uint32 value);

  // bool synchronized = 5;
  void clear_synchronized();
  static const int kSynchronizedFieldNumber = 5;
  bool synchronized() const;
  void set_synchronized(bool value);

  // int32 bucket_size = 6;
  void clear_bucket_size();
  static const int kBucketSizeFieldNumber = 6;
  ::google::protobuf::int32 bucket_size() const;
  void set_bucket_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpcpb.NodeInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::rpcpb::RouteTable > route_table_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr coinbase_;
  ::google::protobuf::internal::ArenaStringPtr protocol_version_;
  ::google::protobuf::uint32 chain_id_;
  ::google::protobuf::uint32 peer_count_;
  bool synchronized_;
  ::google::protobuf::int32 bucket_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsNodeInfoResponseImpl();
};
// -------------------------------------------------------------------

class RouteTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.RouteTable) */ {
 public:
  RouteTable();
  virtual ~RouteTable();

  RouteTable(const RouteTable& from);

  inline RouteTable& operator=(const RouteTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteTable(RouteTable&& from) noexcept
    : RouteTable() {
    *this = ::std::move(from);
  }

  inline RouteTable& operator=(RouteTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteTable* internal_default_instance() {
    return reinterpret_cast<const RouteTable*>(
               &_RouteTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RouteTable* other);
  friend void swap(RouteTable& a, RouteTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteTable* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteTable& from);
  void MergeFrom(const RouteTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string address = 2;
  int address_size() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address(int index) const;
  ::std::string* mutable_address(int index);
  void set_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_address(int index, ::std::string&& value);
  #endif
  void set_address(int index, const char* value);
  void set_address(int index, const char* value, size_t size);
  ::std::string* add_address();
  void add_address(const ::std::string& value);
  #if LANG_CXX11
  void add_address(::std::string&& value);
  #endif
  void add_address(const char* value);
  void add_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_address();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:rpcpb.RouteTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> address_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsRouteTableImpl();
};
// -------------------------------------------------------------------

class GetNebStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GetNebStateResponse) */ {
 public:
  GetNebStateResponse();
  virtual ~GetNebStateResponse();

  GetNebStateResponse(const GetNebStateResponse& from);

  inline GetNebStateResponse& operator=(const GetNebStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNebStateResponse(GetNebStateResponse&& from) noexcept
    : GetNebStateResponse() {
    *this = ::std::move(from);
  }

  inline GetNebStateResponse& operator=(GetNebStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNebStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNebStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetNebStateResponse*>(
               &_GetNebStateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(GetNebStateResponse* other);
  friend void swap(GetNebStateResponse& a, GetNebStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNebStateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNebStateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNebStateResponse& from);
  void MergeFrom(const GetNebStateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNebStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tail = 2;
  void clear_tail();
  static const int kTailFieldNumber = 2;
  const ::std::string& tail() const;
  void set_tail(const ::std::string& value);
  #if LANG_CXX11
  void set_tail(::std::string&& value);
  #endif
  void set_tail(const char* value);
  void set_tail(const char* value, size_t size);
  ::std::string* mutable_tail();
  ::std::string* release_tail();
  void set_allocated_tail(::std::string* tail);

  // string lib = 3;
  void clear_lib();
  static const int kLibFieldNumber = 3;
  const ::std::string& lib() const;
  void set_lib(const ::std::string& value);
  #if LANG_CXX11
  void set_lib(::std::string&& value);
  #endif
  void set_lib(const char* value);
  void set_lib(const char* value, size_t size);
  ::std::string* mutable_lib();
  ::std::string* release_lib();
  void set_allocated_lib(::std::string* lib);

  // string protocol_version = 6;
  void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 6;
  const ::std::string& protocol_version() const;
  void set_protocol_version(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol_version(::std::string&& value);
  #endif
  void set_protocol_version(const char* value);
  void set_protocol_version(const char* value, size_t size);
  ::std::string* mutable_protocol_version();
  ::std::string* release_protocol_version();
  void set_allocated_protocol_version(::std::string* protocol_version);

  // string version = 8;
  void clear_version();
  static const int kVersionFieldNumber = 8;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // uint64 height = 4;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // uint32 chain_id = 1;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 1;
  ::google::protobuf::uint32 chain_id() const;
  void set_chain_id(::google::protobuf::uint32 value);

  // bool synchronized = 7;
  void clear_synchronized();
  static const int kSynchronizedFieldNumber = 7;
  bool synchronized() const;
  void set_synchronized(bool value);

  // @@protoc_insertion_point(class_scope:rpcpb.GetNebStateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tail_;
  ::google::protobuf::internal::ArenaStringPtr lib_;
  ::google::protobuf::internal::ArenaStringPtr protocol_version_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::uint64 height_;
  ::google::protobuf::uint32 chain_id_;
  bool synchronized_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGetNebStateResponseImpl();
};
// -------------------------------------------------------------------

class AccountsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.AccountsResponse) */ {
 public:
  AccountsResponse();
  virtual ~AccountsResponse();

  AccountsResponse(const AccountsResponse& from);

  inline AccountsResponse& operator=(const AccountsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountsResponse(AccountsResponse&& from) noexcept
    : AccountsResponse() {
    *this = ::std::move(from);
  }

  inline AccountsResponse& operator=(AccountsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountsResponse* internal_default_instance() {
    return reinterpret_cast<const AccountsResponse*>(
               &_AccountsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(AccountsResponse* other);
  friend void swap(AccountsResponse& a, AccountsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountsResponse& from);
  void MergeFrom(const AccountsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string addresses = 1;
  int addresses_size() const;
  void clear_addresses();
  static const int kAddressesFieldNumber = 1;
  const ::std::string& addresses(int index) const;
  ::std::string* mutable_addresses(int index);
  void set_addresses(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_addresses(int index, ::std::string&& value);
  #endif
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  ::std::string* add_addresses();
  void add_addresses(const ::std::string& value);
  #if LANG_CXX11
  void add_addresses(::std::string&& value);
  #endif
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& addresses() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_addresses();

  // @@protoc_insertion_point(class_scope:rpcpb.AccountsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> addresses_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsAccountsResponseImpl();
};
// -------------------------------------------------------------------

class GetAccountStateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GetAccountStateRequest) */ {
 public:
  GetAccountStateRequest();
  virtual ~GetAccountStateRequest();

  GetAccountStateRequest(const GetAccountStateRequest& from);

  inline GetAccountStateRequest& operator=(const GetAccountStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountStateRequest(GetAccountStateRequest&& from) noexcept
    : GetAccountStateRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountStateRequest& operator=(GetAccountStateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAccountStateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAccountStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountStateRequest*>(
               &_GetAccountStateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(GetAccountStateRequest* other);
  friend void swap(GetAccountStateRequest& a, GetAccountStateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountStateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAccountStateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAccountStateRequest& from);
  void MergeFrom(const GetAccountStateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAccountStateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // uint64 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:rpcpb.GetAccountStateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint64 height_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGetAccountStateRequestImpl();
};
// -------------------------------------------------------------------

class GetAccountStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GetAccountStateResponse) */ {
 public:
  GetAccountStateResponse();
  virtual ~GetAccountStateResponse();

  GetAccountStateResponse(const GetAccountStateResponse& from);

  inline GetAccountStateResponse& operator=(const GetAccountStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountStateResponse(GetAccountStateResponse&& from) noexcept
    : GetAccountStateResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountStateResponse& operator=(GetAccountStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAccountStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAccountStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountStateResponse*>(
               &_GetAccountStateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(GetAccountStateResponse* other);
  friend void swap(GetAccountStateResponse& a, GetAccountStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountStateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAccountStateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAccountStateResponse& from);
  void MergeFrom(const GetAccountStateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAccountStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string balance = 1;
  void clear_balance();
  static const int kBalanceFieldNumber = 1;
  const ::std::string& balance() const;
  void set_balance(const ::std::string& value);
  #if LANG_CXX11
  void set_balance(::std::string&& value);
  #endif
  void set_balance(const char* value);
  void set_balance(const char* value, size_t size);
  ::std::string* mutable_balance();
  ::std::string* release_balance();
  void set_allocated_balance(::std::string* balance);

  // uint64 nonce = 2;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // uint32 type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rpcpb.GetAccountStateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr balance_;
  ::google::protobuf::uint64 nonce_;
  ::google::protobuf::uint32 type_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGetAccountStateResponseImpl();
};
// -------------------------------------------------------------------

class CallResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.CallResponse) */ {
 public:
  CallResponse();
  virtual ~CallResponse();

  CallResponse(const CallResponse& from);

  inline CallResponse& operator=(const CallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CallResponse(CallResponse&& from) noexcept
    : CallResponse() {
    *this = ::std::move(from);
  }

  inline CallResponse& operator=(CallResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CallResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CallResponse* internal_default_instance() {
    return reinterpret_cast<const CallResponse*>(
               &_CallResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CallResponse* other);
  friend void swap(CallResponse& a, CallResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CallResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CallResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CallResponse& from);
  void MergeFrom(const CallResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CallResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::std::string& result() const;
  void set_result(const ::std::string& value);
  #if LANG_CXX11
  void set_result(::std::string&& value);
  #endif
  void set_result(const char* value);
  void set_result(const char* value, size_t size);
  ::std::string* mutable_result();
  ::std::string* release_result();
  void set_allocated_result(::std::string* result);

  // string execute_err = 2;
  void clear_execute_err();
  static const int kExecuteErrFieldNumber = 2;
  const ::std::string& execute_err() const;
  void set_execute_err(const ::std::string& value);
  #if LANG_CXX11
  void set_execute_err(::std::string&& value);
  #endif
  void set_execute_err(const char* value);
  void set_execute_err(const char* value, size_t size);
  ::std::string* mutable_execute_err();
  ::std::string* release_execute_err();
  void set_allocated_execute_err(::std::string* execute_err);

  // string estimate_gas = 3;
  void clear_estimate_gas();
  static const int kEstimateGasFieldNumber = 3;
  const ::std::string& estimate_gas() const;
  void set_estimate_gas(const ::std::string& value);
  #if LANG_CXX11
  void set_estimate_gas(::std::string&& value);
  #endif
  void set_estimate_gas(const char* value);
  void set_estimate_gas(const char* value, size_t size);
  ::std::string* mutable_estimate_gas();
  ::std::string* release_estimate_gas();
  void set_allocated_estimate_gas(::std::string* estimate_gas);

  // @@protoc_insertion_point(class_scope:rpcpb.CallResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr result_;
  ::google::protobuf::internal::ArenaStringPtr execute_err_;
  ::google::protobuf::internal::ArenaStringPtr estimate_gas_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsCallResponseImpl();
};
// -------------------------------------------------------------------

class ByBlockHeightRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.ByBlockHeightRequest) */ {
 public:
  ByBlockHeightRequest();
  virtual ~ByBlockHeightRequest();

  ByBlockHeightRequest(const ByBlockHeightRequest& from);

  inline ByBlockHeightRequest& operator=(const ByBlockHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ByBlockHeightRequest(ByBlockHeightRequest&& from) noexcept
    : ByBlockHeightRequest() {
    *this = ::std::move(from);
  }

  inline ByBlockHeightRequest& operator=(ByBlockHeightRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ByBlockHeightRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ByBlockHeightRequest* internal_default_instance() {
    return reinterpret_cast<const ByBlockHeightRequest*>(
               &_ByBlockHeightRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ByBlockHeightRequest* other);
  friend void swap(ByBlockHeightRequest& a, ByBlockHeightRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ByBlockHeightRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ByBlockHeightRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ByBlockHeightRequest& from);
  void MergeFrom(const ByBlockHeightRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ByBlockHeightRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:rpcpb.ByBlockHeightRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 height_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsByBlockHeightRequestImpl();
};
// -------------------------------------------------------------------

class GetDynastyResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GetDynastyResponse) */ {
 public:
  GetDynastyResponse();
  virtual ~GetDynastyResponse();

  GetDynastyResponse(const GetDynastyResponse& from);

  inline GetDynastyResponse& operator=(const GetDynastyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDynastyResponse(GetDynastyResponse&& from) noexcept
    : GetDynastyResponse() {
    *this = ::std::move(from);
  }

  inline GetDynastyResponse& operator=(GetDynastyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDynastyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDynastyResponse* internal_default_instance() {
    return reinterpret_cast<const GetDynastyResponse*>(
               &_GetDynastyResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(GetDynastyResponse* other);
  friend void swap(GetDynastyResponse& a, GetDynastyResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDynastyResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetDynastyResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetDynastyResponse& from);
  void MergeFrom(const GetDynastyResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetDynastyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string miners = 1;
  int miners_size() const;
  void clear_miners();
  static const int kMinersFieldNumber = 1;
  const ::std::string& miners(int index) const;
  ::std::string* mutable_miners(int index);
  void set_miners(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_miners(int index, ::std::string&& value);
  #endif
  void set_miners(int index, const char* value);
  void set_miners(int index, const char* value, size_t size);
  ::std::string* add_miners();
  void add_miners(const ::std::string& value);
  #if LANG_CXX11
  void add_miners(::std::string&& value);
  #endif
  void add_miners(const char* value);
  void add_miners(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& miners() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_miners();

  // @@protoc_insertion_point(class_scope:rpcpb.GetDynastyResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> miners_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGetDynastyResponseImpl();
};
// -------------------------------------------------------------------

class TransactionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.TransactionRequest) */ {
 public:
  TransactionRequest();
  virtual ~TransactionRequest();

  TransactionRequest(const TransactionRequest& from);

  inline TransactionRequest& operator=(const TransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionRequest(TransactionRequest&& from) noexcept
    : TransactionRequest() {
    *this = ::std::move(from);
  }

  inline TransactionRequest& operator=(TransactionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionRequest* internal_default_instance() {
    return reinterpret_cast<const TransactionRequest*>(
               &_TransactionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TransactionRequest* other);
  friend void swap(TransactionRequest& a, TransactionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionRequest& from);
  void MergeFrom(const TransactionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // string value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string gas_price = 5;
  void clear_gas_price();
  static const int kGasPriceFieldNumber = 5;
  const ::std::string& gas_price() const;
  void set_gas_price(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_price(::std::string&& value);
  #endif
  void set_gas_price(const char* value);
  void set_gas_price(const char* value, size_t size);
  ::std::string* mutable_gas_price();
  ::std::string* release_gas_price();
  void set_allocated_gas_price(::std::string* gas_price);

  // string gas_limit = 6;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 6;
  const ::std::string& gas_limit() const;
  void set_gas_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_limit(::std::string&& value);
  #endif
  void set_gas_limit(const char* value);
  void set_gas_limit(const char* value, size_t size);
  ::std::string* mutable_gas_limit();
  ::std::string* release_gas_limit();
  void set_allocated_gas_limit(::std::string* gas_limit);

  // bytes binary = 10;
  void clear_binary();
  static const int kBinaryFieldNumber = 10;
  const ::std::string& binary() const;
  void set_binary(const ::std::string& value);
  #if LANG_CXX11
  void set_binary(::std::string&& value);
  #endif
  void set_binary(const char* value);
  void set_binary(const void* value, size_t size);
  ::std::string* mutable_binary();
  ::std::string* release_binary();
  void set_allocated_binary(::std::string* binary);

  // string type = 20;
  void clear_type();
  static const int kTypeFieldNumber = 20;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .rpcpb.ContractRequest contract = 7;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 7;
  const ::rpcpb::ContractRequest& contract() const;
  ::rpcpb::ContractRequest* release_contract();
  ::rpcpb::ContractRequest* mutable_contract();
  void set_allocated_contract(::rpcpb::ContractRequest* contract);

  // uint64 nonce = 4;
  void clear_nonce();
  static const int kNonceFieldNumber = 4;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:rpcpb.TransactionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr gas_price_;
  ::google::protobuf::internal::ArenaStringPtr gas_limit_;
  ::google::protobuf::internal::ArenaStringPtr binary_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::rpcpb::ContractRequest* contract_;
  ::google::protobuf::uint64 nonce_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsTransactionRequestImpl();
};
// -------------------------------------------------------------------

class ContractRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.ContractRequest) */ {
 public:
  ContractRequest();
  virtual ~ContractRequest();

  ContractRequest(const ContractRequest& from);

  inline ContractRequest& operator=(const ContractRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContractRequest(ContractRequest&& from) noexcept
    : ContractRequest() {
    *this = ::std::move(from);
  }

  inline ContractRequest& operator=(ContractRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContractRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractRequest* internal_default_instance() {
    return reinterpret_cast<const ContractRequest*>(
               &_ContractRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ContractRequest* other);
  friend void swap(ContractRequest& a, ContractRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContractRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ContractRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContractRequest& from);
  void MergeFrom(const ContractRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContractRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string source = 1;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // string source_type = 2;
  void clear_source_type();
  static const int kSourceTypeFieldNumber = 2;
  const ::std::string& source_type() const;
  void set_source_type(const ::std::string& value);
  #if LANG_CXX11
  void set_source_type(::std::string&& value);
  #endif
  void set_source_type(const char* value);
  void set_source_type(const char* value, size_t size);
  ::std::string* mutable_source_type();
  ::std::string* release_source_type();
  void set_allocated_source_type(::std::string* source_type);

  // string function = 3;
  void clear_function();
  static const int kFunctionFieldNumber = 3;
  const ::std::string& function() const;
  void set_function(const ::std::string& value);
  #if LANG_CXX11
  void set_function(::std::string&& value);
  #endif
  void set_function(const char* value);
  void set_function(const char* value, size_t size);
  ::std::string* mutable_function();
  ::std::string* release_function();
  void set_allocated_function(::std::string* function);

  // string args = 4;
  void clear_args();
  static const int kArgsFieldNumber = 4;
  const ::std::string& args() const;
  void set_args(const ::std::string& value);
  #if LANG_CXX11
  void set_args(::std::string&& value);
  #endif
  void set_args(const char* value);
  void set_args(const char* value, size_t size);
  ::std::string* mutable_args();
  ::std::string* release_args();
  void set_allocated_args(::std::string* args);

  // @@protoc_insertion_point(class_scope:rpcpb.ContractRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr source_type_;
  ::google::protobuf::internal::ArenaStringPtr function_;
  ::google::protobuf::internal::ArenaStringPtr args_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsContractRequestImpl();
};
// -------------------------------------------------------------------

class SendRawTransactionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.SendRawTransactionRequest) */ {
 public:
  SendRawTransactionRequest();
  virtual ~SendRawTransactionRequest();

  SendRawTransactionRequest(const SendRawTransactionRequest& from);

  inline SendRawTransactionRequest& operator=(const SendRawTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendRawTransactionRequest(SendRawTransactionRequest&& from) noexcept
    : SendRawTransactionRequest() {
    *this = ::std::move(from);
  }

  inline SendRawTransactionRequest& operator=(SendRawTransactionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendRawTransactionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendRawTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const SendRawTransactionRequest*>(
               &_SendRawTransactionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(SendRawTransactionRequest* other);
  friend void swap(SendRawTransactionRequest& a, SendRawTransactionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendRawTransactionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SendRawTransactionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SendRawTransactionRequest& from);
  void MergeFrom(const SendRawTransactionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SendRawTransactionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:rpcpb.SendRawTransactionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsSendRawTransactionRequestImpl();
};
// -------------------------------------------------------------------

class SendTransactionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.SendTransactionResponse) */ {
 public:
  SendTransactionResponse();
  virtual ~SendTransactionResponse();

  SendTransactionResponse(const SendTransactionResponse& from);

  inline SendTransactionResponse& operator=(const SendTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendTransactionResponse(SendTransactionResponse&& from) noexcept
    : SendTransactionResponse() {
    *this = ::std::move(from);
  }

  inline SendTransactionResponse& operator=(SendTransactionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendTransactionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const SendTransactionResponse*>(
               &_SendTransactionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(SendTransactionResponse* other);
  friend void swap(SendTransactionResponse& a, SendTransactionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendTransactionResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SendTransactionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SendTransactionResponse& from);
  void MergeFrom(const SendTransactionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SendTransactionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string txhash = 1;
  void clear_txhash();
  static const int kTxhashFieldNumber = 1;
  const ::std::string& txhash() const;
  void set_txhash(const ::std::string& value);
  #if LANG_CXX11
  void set_txhash(::std::string&& value);
  #endif
  void set_txhash(const char* value);
  void set_txhash(const char* value, size_t size);
  ::std::string* mutable_txhash();
  ::std::string* release_txhash();
  void set_allocated_txhash(::std::string* txhash);

  // string contract_address = 2;
  void clear_contract_address();
  static const int kContractAddressFieldNumber = 2;
  const ::std::string& contract_address() const;
  void set_contract_address(const ::std::string& value);
  #if LANG_CXX11
  void set_contract_address(::std::string&& value);
  #endif
  void set_contract_address(const char* value);
  void set_contract_address(const char* value, size_t size);
  ::std::string* mutable_contract_address();
  ::std::string* release_contract_address();
  void set_allocated_contract_address(::std::string* contract_address);

  // @@protoc_insertion_point(class_scope:rpcpb.SendTransactionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr txhash_;
  ::google::protobuf::internal::ArenaStringPtr contract_address_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsSendTransactionResponseImpl();
};
// -------------------------------------------------------------------

class GetBlockByHashRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GetBlockByHashRequest) */ {
 public:
  GetBlockByHashRequest();
  virtual ~GetBlockByHashRequest();

  GetBlockByHashRequest(const GetBlockByHashRequest& from);

  inline GetBlockByHashRequest& operator=(const GetBlockByHashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockByHashRequest(GetBlockByHashRequest&& from) noexcept
    : GetBlockByHashRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockByHashRequest& operator=(GetBlockByHashRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockByHashRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockByHashRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockByHashRequest*>(
               &_GetBlockByHashRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(GetBlockByHashRequest* other);
  friend void swap(GetBlockByHashRequest& a, GetBlockByHashRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockByHashRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetBlockByHashRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetBlockByHashRequest& from);
  void MergeFrom(const GetBlockByHashRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetBlockByHashRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // bool full_fill_transaction = 2;
  void clear_full_fill_transaction();
  static const int kFullFillTransactionFieldNumber = 2;
  bool full_fill_transaction() const;
  void set_full_fill_transaction(bool value);

  // @@protoc_insertion_point(class_scope:rpcpb.GetBlockByHashRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  bool full_fill_transaction_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGetBlockByHashRequestImpl();
};
// -------------------------------------------------------------------

class GetBlockByHeightRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GetBlockByHeightRequest) */ {
 public:
  GetBlockByHeightRequest();
  virtual ~GetBlockByHeightRequest();

  GetBlockByHeightRequest(const GetBlockByHeightRequest& from);

  inline GetBlockByHeightRequest& operator=(const GetBlockByHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBlockByHeightRequest(GetBlockByHeightRequest&& from) noexcept
    : GetBlockByHeightRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockByHeightRequest& operator=(GetBlockByHeightRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlockByHeightRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBlockByHeightRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockByHeightRequest*>(
               &_GetBlockByHeightRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(GetBlockByHeightRequest* other);
  friend void swap(GetBlockByHeightRequest& a, GetBlockByHeightRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBlockByHeightRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetBlockByHeightRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetBlockByHeightRequest& from);
  void MergeFrom(const GetBlockByHeightRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetBlockByHeightRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // bool full_fill_transaction = 2;
  void clear_full_fill_transaction();
  static const int kFullFillTransactionFieldNumber = 2;
  bool full_fill_transaction() const;
  void set_full_fill_transaction(bool value);

  // @@protoc_insertion_point(class_scope:rpcpb.GetBlockByHeightRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 height_;
  bool full_fill_transaction_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGetBlockByHeightRequestImpl();
};
// -------------------------------------------------------------------

class GetTransactionByHashRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GetTransactionByHashRequest) */ {
 public:
  GetTransactionByHashRequest();
  virtual ~GetTransactionByHashRequest();

  GetTransactionByHashRequest(const GetTransactionByHashRequest& from);

  inline GetTransactionByHashRequest& operator=(const GetTransactionByHashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTransactionByHashRequest(GetTransactionByHashRequest&& from) noexcept
    : GetTransactionByHashRequest() {
    *this = ::std::move(from);
  }

  inline GetTransactionByHashRequest& operator=(GetTransactionByHashRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTransactionByHashRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTransactionByHashRequest* internal_default_instance() {
    return reinterpret_cast<const GetTransactionByHashRequest*>(
               &_GetTransactionByHashRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(GetTransactionByHashRequest* other);
  friend void swap(GetTransactionByHashRequest& a, GetTransactionByHashRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTransactionByHashRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTransactionByHashRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTransactionByHashRequest& from);
  void MergeFrom(const GetTransactionByHashRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTransactionByHashRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:rpcpb.GetTransactionByHashRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGetTransactionByHashRequestImpl();
};
// -------------------------------------------------------------------

class GetTransactionByContractRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GetTransactionByContractRequest) */ {
 public:
  GetTransactionByContractRequest();
  virtual ~GetTransactionByContractRequest();

  GetTransactionByContractRequest(const GetTransactionByContractRequest& from);

  inline GetTransactionByContractRequest& operator=(const GetTransactionByContractRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTransactionByContractRequest(GetTransactionByContractRequest&& from) noexcept
    : GetTransactionByContractRequest() {
    *this = ::std::move(from);
  }

  inline GetTransactionByContractRequest& operator=(GetTransactionByContractRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTransactionByContractRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTransactionByContractRequest* internal_default_instance() {
    return reinterpret_cast<const GetTransactionByContractRequest*>(
               &_GetTransactionByContractRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(GetTransactionByContractRequest* other);
  friend void swap(GetTransactionByContractRequest& a, GetTransactionByContractRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTransactionByContractRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTransactionByContractRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTransactionByContractRequest& from);
  void MergeFrom(const GetTransactionByContractRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTransactionByContractRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:rpcpb.GetTransactionByContractRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGetTransactionByContractRequestImpl();
};
// -------------------------------------------------------------------

class BlockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.BlockResponse) */ {
 public:
  BlockResponse();
  virtual ~BlockResponse();

  BlockResponse(const BlockResponse& from);

  inline BlockResponse& operator=(const BlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockResponse(BlockResponse&& from) noexcept
    : BlockResponse() {
    *this = ::std::move(from);
  }

  inline BlockResponse& operator=(BlockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockResponse* internal_default_instance() {
    return reinterpret_cast<const BlockResponse*>(
               &_BlockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(BlockResponse* other);
  friend void swap(BlockResponse& a, BlockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockResponse& from);
  void MergeFrom(const BlockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rpcpb.TransactionResponse transactions = 100;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 100;
  const ::rpcpb::TransactionResponse& transactions(int index) const;
  ::rpcpb::TransactionResponse* mutable_transactions(int index);
  ::rpcpb::TransactionResponse* add_transactions();
  ::google::protobuf::RepeatedPtrField< ::rpcpb::TransactionResponse >*
      mutable_transactions();
  const ::google::protobuf::RepeatedPtrField< ::rpcpb::TransactionResponse >&
      transactions() const;

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string parent_hash = 2;
  void clear_parent_hash();
  static const int kParentHashFieldNumber = 2;
  const ::std::string& parent_hash() const;
  void set_parent_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_hash(::std::string&& value);
  #endif
  void set_parent_hash(const char* value);
  void set_parent_hash(const char* value, size_t size);
  ::std::string* mutable_parent_hash();
  ::std::string* release_parent_hash();
  void set_allocated_parent_hash(::std::string* parent_hash);

  // string coinbase = 5;
  void clear_coinbase();
  static const int kCoinbaseFieldNumber = 5;
  const ::std::string& coinbase() const;
  void set_coinbase(const ::std::string& value);
  #if LANG_CXX11
  void set_coinbase(::std::string&& value);
  #endif
  void set_coinbase(const char* value);
  void set_coinbase(const char* value, size_t size);
  ::std::string* mutable_coinbase();
  ::std::string* release_coinbase();
  void set_allocated_coinbase(::std::string* coinbase);

  // string state_root = 8;
  void clear_state_root();
  static const int kStateRootFieldNumber = 8;
  const ::std::string& state_root() const;
  void set_state_root(const ::std::string& value);
  #if LANG_CXX11
  void set_state_root(::std::string&& value);
  #endif
  void set_state_root(const char* value);
  void set_state_root(const char* value, size_t size);
  ::std::string* mutable_state_root();
  ::std::string* release_state_root();
  void set_allocated_state_root(::std::string* state_root);

  // string txs_root = 9;
  void clear_txs_root();
  static const int kTxsRootFieldNumber = 9;
  const ::std::string& txs_root() const;
  void set_txs_root(const ::std::string& value);
  #if LANG_CXX11
  void set_txs_root(::std::string&& value);
  #endif
  void set_txs_root(const char* value);
  void set_txs_root(const char* value, size_t size);
  ::std::string* mutable_txs_root();
  ::std::string* release_txs_root();
  void set_allocated_txs_root(::std::string* txs_root);

  // string events_root = 10;
  void clear_events_root();
  static const int kEventsRootFieldNumber = 10;
  const ::std::string& events_root() const;
  void set_events_root(const ::std::string& value);
  #if LANG_CXX11
  void set_events_root(::std::string&& value);
  #endif
  void set_events_root(const char* value);
  void set_events_root(const char* value, size_t size);
  ::std::string* mutable_events_root();
  ::std::string* release_events_root();
  void set_allocated_events_root(::std::string* events_root);

  // string miner = 12;
  void clear_miner();
  static const int kMinerFieldNumber = 12;
  const ::std::string& miner() const;
  void set_miner(const ::std::string& value);
  #if LANG_CXX11
  void set_miner(::std::string&& value);
  #endif
  void set_miner(const char* value);
  void set_miner(const char* value, size_t size);
  ::std::string* mutable_miner();
  ::std::string* release_miner();
  void set_allocated_miner(::std::string* miner);

  // string randomSeed = 13;
  void clear_randomseed();
  static const int kRandomSeedFieldNumber = 13;
  const ::std::string& randomseed() const;
  void set_randomseed(const ::std::string& value);
  #if LANG_CXX11
  void set_randomseed(::std::string&& value);
  #endif
  void set_randomseed(const char* value);
  void set_randomseed(const char* value, size_t size);
  ::std::string* mutable_randomseed();
  ::std::string* release_randomseed();
  void set_allocated_randomseed(::std::string* randomseed);

  // string randomProof = 14;
  void clear_randomproof();
  static const int kRandomProofFieldNumber = 14;
  const ::std::string& randomproof() const;
  void set_randomproof(const ::std::string& value);
  #if LANG_CXX11
  void set_randomproof(::std::string&& value);
  #endif
  void set_randomproof(const char* value);
  void set_randomproof(const char* value, size_t size);
  ::std::string* mutable_randomproof();
  ::std::string* release_randomproof();
  void set_allocated_randomproof(::std::string* randomproof);

  // .consensuspb.ConsensusRoot consensus_root = 11;
  bool has_consensus_root() const;
  void clear_consensus_root();
  static const int kConsensusRootFieldNumber = 11;
  const ::consensuspb::ConsensusRoot& consensus_root() const;
  ::consensuspb::ConsensusRoot* release_consensus_root();
  ::consensuspb::ConsensusRoot* mutable_consensus_root();
  void set_allocated_consensus_root(::consensuspb::ConsensusRoot* consensus_root);

  // uint64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // uint64 nonce = 4;
  void clear_nonce();
  static const int kNonceFieldNumber = 4;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // int64 timestamp = 6;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // uint32 chain_id = 7;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 7;
  ::google::protobuf::uint32 chain_id() const;
  void set_chain_id(::google::protobuf::uint32 value);

  // bool is_finality = 15;
  void clear_is_finality();
  static const int kIsFinalityFieldNumber = 15;
  bool is_finality() const;
  void set_is_finality(bool value);

  // @@protoc_insertion_point(class_scope:rpcpb.BlockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::rpcpb::TransactionResponse > transactions_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr parent_hash_;
  ::google::protobuf::internal::ArenaStringPtr coinbase_;
  ::google::protobuf::internal::ArenaStringPtr state_root_;
  ::google::protobuf::internal::ArenaStringPtr txs_root_;
  ::google::protobuf::internal::ArenaStringPtr events_root_;
  ::google::protobuf::internal::ArenaStringPtr miner_;
  ::google::protobuf::internal::ArenaStringPtr randomseed_;
  ::google::protobuf::internal::ArenaStringPtr randomproof_;
  ::consensuspb::ConsensusRoot* consensus_root_;
  ::google::protobuf::uint64 height_;
  ::google::protobuf::uint64 nonce_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::uint32 chain_id_;
  bool is_finality_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsBlockResponseImpl();
};
// -------------------------------------------------------------------

class TransactionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.TransactionResponse) */ {
 public:
  TransactionResponse();
  virtual ~TransactionResponse();

  TransactionResponse(const TransactionResponse& from);

  inline TransactionResponse& operator=(const TransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionResponse(TransactionResponse&& from) noexcept
    : TransactionResponse() {
    *this = ::std::move(from);
  }

  inline TransactionResponse& operator=(TransactionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionResponse*>(
               &_TransactionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(TransactionResponse* other);
  friend void swap(TransactionResponse& a, TransactionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionResponse& from);
  void MergeFrom(const TransactionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string from = 3;
  void clear_from();
  static const int kFromFieldNumber = 3;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // string to = 4;
  void clear_to();
  static const int kToFieldNumber = 4;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // string value = 5;
  void clear_value();
  static const int kValueFieldNumber = 5;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string type = 8;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bytes data = 9;
  void clear_data();
  static const int kDataFieldNumber = 9;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string gas_price = 10;
  void clear_gas_price();
  static const int kGasPriceFieldNumber = 10;
  const ::std::string& gas_price() const;
  void set_gas_price(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_price(::std::string&& value);
  #endif
  void set_gas_price(const char* value);
  void set_gas_price(const char* value, size_t size);
  ::std::string* mutable_gas_price();
  ::std::string* release_gas_price();
  void set_allocated_gas_price(::std::string* gas_price);

  // string gas_limit = 11;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 11;
  const ::std::string& gas_limit() const;
  void set_gas_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_limit(::std::string&& value);
  #endif
  void set_gas_limit(const char* value);
  void set_gas_limit(const char* value, size_t size);
  ::std::string* mutable_gas_limit();
  ::std::string* release_gas_limit();
  void set_allocated_gas_limit(::std::string* gas_limit);

  // string contract_address = 12;
  void clear_contract_address();
  static const int kContractAddressFieldNumber = 12;
  const ::std::string& contract_address() const;
  void set_contract_address(const ::std::string& value);
  #if LANG_CXX11
  void set_contract_address(::std::string&& value);
  #endif
  void set_contract_address(const char* value);
  void set_contract_address(const char* value, size_t size);
  ::std::string* mutable_contract_address();
  ::std::string* release_contract_address();
  void set_allocated_contract_address(::std::string* contract_address);

  // string gas_used = 14;
  void clear_gas_used();
  static const int kGasUsedFieldNumber = 14;
  const ::std::string& gas_used() const;
  void set_gas_used(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_used(::std::string&& value);
  #endif
  void set_gas_used(const char* value);
  void set_gas_used(const char* value, size_t size);
  ::std::string* mutable_gas_used();
  ::std::string* release_gas_used();
  void set_allocated_gas_used(::std::string* gas_used);

  // string execute_error = 15;
  void clear_execute_error();
  static const int kExecuteErrorFieldNumber = 15;
  const ::std::string& execute_error() const;
  void set_execute_error(const ::std::string& value);
  #if LANG_CXX11
  void set_execute_error(::std::string&& value);
  #endif
  void set_execute_error(const char* value);
  void set_execute_error(const char* value, size_t size);
  ::std::string* mutable_execute_error();
  ::std::string* release_execute_error();
  void set_allocated_execute_error(::std::string* execute_error);

  // string execute_result = 16;
  void clear_execute_result();
  static const int kExecuteResultFieldNumber = 16;
  const ::std::string& execute_result() const;
  void set_execute_result(const ::std::string& value);
  #if LANG_CXX11
  void set_execute_result(::std::string&& value);
  #endif
  void set_execute_result(const char* value);
  void set_execute_result(const char* value, size_t size);
  ::std::string* mutable_execute_result();
  ::std::string* release_execute_result();
  void set_allocated_execute_result(::std::string* execute_result);

  // uint64 nonce = 6;
  void clear_nonce();
  static const int kNonceFieldNumber = 6;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // int64 timestamp = 7;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // uint32 chainId = 2;
  void clear_chainid();
  static const int kChainIdFieldNumber = 2;
  ::google::protobuf::uint32 chainid() const;
  void set_chainid(::google::protobuf::uint32 value);

  // int32 status = 13;
  void clear_status();
  static const int kStatusFieldNumber = 13;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // uint64 block_height = 17;
  void clear_block_height();
  static const int kBlockHeightFieldNumber = 17;
  ::google::protobuf::uint64 block_height() const;
  void set_block_height(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:rpcpb.TransactionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr gas_price_;
  ::google::protobuf::internal::ArenaStringPtr gas_limit_;
  ::google::protobuf::internal::ArenaStringPtr contract_address_;
  ::google::protobuf::internal::ArenaStringPtr gas_used_;
  ::google::protobuf::internal::ArenaStringPtr execute_error_;
  ::google::protobuf::internal::ArenaStringPtr execute_result_;
  ::google::protobuf::uint64 nonce_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::uint32 chainid_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::uint64 block_height_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsTransactionResponseImpl();
};
// -------------------------------------------------------------------

class NewAccountRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.NewAccountRequest) */ {
 public:
  NewAccountRequest();
  virtual ~NewAccountRequest();

  NewAccountRequest(const NewAccountRequest& from);

  inline NewAccountRequest& operator=(const NewAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewAccountRequest(NewAccountRequest&& from) noexcept
    : NewAccountRequest() {
    *this = ::std::move(from);
  }

  inline NewAccountRequest& operator=(NewAccountRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewAccountRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewAccountRequest* internal_default_instance() {
    return reinterpret_cast<const NewAccountRequest*>(
               &_NewAccountRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(NewAccountRequest* other);
  friend void swap(NewAccountRequest& a, NewAccountRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewAccountRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NewAccountRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewAccountRequest& from);
  void MergeFrom(const NewAccountRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewAccountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string passphrase = 1;
  void clear_passphrase();
  static const int kPassphraseFieldNumber = 1;
  const ::std::string& passphrase() const;
  void set_passphrase(const ::std::string& value);
  #if LANG_CXX11
  void set_passphrase(::std::string&& value);
  #endif
  void set_passphrase(const char* value);
  void set_passphrase(const char* value, size_t size);
  ::std::string* mutable_passphrase();
  ::std::string* release_passphrase();
  void set_allocated_passphrase(::std::string* passphrase);

  // @@protoc_insertion_point(class_scope:rpcpb.NewAccountRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr passphrase_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsNewAccountRequestImpl();
};
// -------------------------------------------------------------------

class NewAccountResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.NewAccountResponse) */ {
 public:
  NewAccountResponse();
  virtual ~NewAccountResponse();

  NewAccountResponse(const NewAccountResponse& from);

  inline NewAccountResponse& operator=(const NewAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewAccountResponse(NewAccountResponse&& from) noexcept
    : NewAccountResponse() {
    *this = ::std::move(from);
  }

  inline NewAccountResponse& operator=(NewAccountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewAccountResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewAccountResponse* internal_default_instance() {
    return reinterpret_cast<const NewAccountResponse*>(
               &_NewAccountResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(NewAccountResponse* other);
  friend void swap(NewAccountResponse& a, NewAccountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewAccountResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NewAccountResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewAccountResponse& from);
  void MergeFrom(const NewAccountResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewAccountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:rpcpb.NewAccountResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsNewAccountResponseImpl();
};
// -------------------------------------------------------------------

class UnlockAccountRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.UnlockAccountRequest) */ {
 public:
  UnlockAccountRequest();
  virtual ~UnlockAccountRequest();

  UnlockAccountRequest(const UnlockAccountRequest& from);

  inline UnlockAccountRequest& operator=(const UnlockAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlockAccountRequest(UnlockAccountRequest&& from) noexcept
    : UnlockAccountRequest() {
    *this = ::std::move(from);
  }

  inline UnlockAccountRequest& operator=(UnlockAccountRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockAccountRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnlockAccountRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockAccountRequest*>(
               &_UnlockAccountRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(UnlockAccountRequest* other);
  friend void swap(UnlockAccountRequest& a, UnlockAccountRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlockAccountRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UnlockAccountRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnlockAccountRequest& from);
  void MergeFrom(const UnlockAccountRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnlockAccountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // string passphrase = 2;
  void clear_passphrase();
  static const int kPassphraseFieldNumber = 2;
  const ::std::string& passphrase() const;
  void set_passphrase(const ::std::string& value);
  #if LANG_CXX11
  void set_passphrase(::std::string&& value);
  #endif
  void set_passphrase(const char* value);
  void set_passphrase(const char* value, size_t size);
  ::std::string* mutable_passphrase();
  ::std::string* release_passphrase();
  void set_allocated_passphrase(::std::string* passphrase);

  // uint64 duration = 3;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint64 duration() const;
  void set_duration(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:rpcpb.UnlockAccountRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr passphrase_;
  ::google::protobuf::uint64 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsUnlockAccountRequestImpl();
};
// -------------------------------------------------------------------

class UnlockAccountResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.UnlockAccountResponse) */ {
 public:
  UnlockAccountResponse();
  virtual ~UnlockAccountResponse();

  UnlockAccountResponse(const UnlockAccountResponse& from);

  inline UnlockAccountResponse& operator=(const UnlockAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlockAccountResponse(UnlockAccountResponse&& from) noexcept
    : UnlockAccountResponse() {
    *this = ::std::move(from);
  }

  inline UnlockAccountResponse& operator=(UnlockAccountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockAccountResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnlockAccountResponse* internal_default_instance() {
    return reinterpret_cast<const UnlockAccountResponse*>(
               &_UnlockAccountResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(UnlockAccountResponse* other);
  friend void swap(UnlockAccountResponse& a, UnlockAccountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlockAccountResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UnlockAccountResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnlockAccountResponse& from);
  void MergeFrom(const UnlockAccountResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnlockAccountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:rpcpb.UnlockAccountResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool result_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsUnlockAccountResponseImpl();
};
// -------------------------------------------------------------------

class LockAccountRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.LockAccountRequest) */ {
 public:
  LockAccountRequest();
  virtual ~LockAccountRequest();

  LockAccountRequest(const LockAccountRequest& from);

  inline LockAccountRequest& operator=(const LockAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockAccountRequest(LockAccountRequest&& from) noexcept
    : LockAccountRequest() {
    *this = ::std::move(from);
  }

  inline LockAccountRequest& operator=(LockAccountRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockAccountRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockAccountRequest* internal_default_instance() {
    return reinterpret_cast<const LockAccountRequest*>(
               &_LockAccountRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(LockAccountRequest* other);
  friend void swap(LockAccountRequest& a, LockAccountRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockAccountRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockAccountRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockAccountRequest& from);
  void MergeFrom(const LockAccountRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockAccountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:rpcpb.LockAccountRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsLockAccountRequestImpl();
};
// -------------------------------------------------------------------

class LockAccountResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.LockAccountResponse) */ {
 public:
  LockAccountResponse();
  virtual ~LockAccountResponse();

  LockAccountResponse(const LockAccountResponse& from);

  inline LockAccountResponse& operator=(const LockAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockAccountResponse(LockAccountResponse&& from) noexcept
    : LockAccountResponse() {
    *this = ::std::move(from);
  }

  inline LockAccountResponse& operator=(LockAccountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockAccountResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockAccountResponse* internal_default_instance() {
    return reinterpret_cast<const LockAccountResponse*>(
               &_LockAccountResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(LockAccountResponse* other);
  friend void swap(LockAccountResponse& a, LockAccountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockAccountResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LockAccountResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockAccountResponse& from);
  void MergeFrom(const LockAccountResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockAccountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:rpcpb.LockAccountResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool result_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsLockAccountResponseImpl();
};
// -------------------------------------------------------------------

class SignHashRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.SignHashRequest) */ {
 public:
  SignHashRequest();
  virtual ~SignHashRequest();

  SignHashRequest(const SignHashRequest& from);

  inline SignHashRequest& operator=(const SignHashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignHashRequest(SignHashRequest&& from) noexcept
    : SignHashRequest() {
    *this = ::std::move(from);
  }

  inline SignHashRequest& operator=(SignHashRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignHashRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignHashRequest* internal_default_instance() {
    return reinterpret_cast<const SignHashRequest*>(
               &_SignHashRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(SignHashRequest* other);
  friend void swap(SignHashRequest& a, SignHashRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignHashRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SignHashRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignHashRequest& from);
  void MergeFrom(const SignHashRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignHashRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // bytes hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // uint32 alg = 3;
  void clear_alg();
  static const int kAlgFieldNumber = 3;
  ::google::protobuf::uint32 alg() const;
  void set_alg(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rpcpb.SignHashRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint32 alg_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsSignHashRequestImpl();
};
// -------------------------------------------------------------------

class SignHashResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.SignHashResponse) */ {
 public:
  SignHashResponse();
  virtual ~SignHashResponse();

  SignHashResponse(const SignHashResponse& from);

  inline SignHashResponse& operator=(const SignHashResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignHashResponse(SignHashResponse&& from) noexcept
    : SignHashResponse() {
    *this = ::std::move(from);
  }

  inline SignHashResponse& operator=(SignHashResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignHashResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignHashResponse* internal_default_instance() {
    return reinterpret_cast<const SignHashResponse*>(
               &_SignHashResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(SignHashResponse* other);
  friend void swap(SignHashResponse& a, SignHashResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignHashResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SignHashResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignHashResponse& from);
  void MergeFrom(const SignHashResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignHashResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:rpcpb.SignHashResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsSignHashResponseImpl();
};
// -------------------------------------------------------------------

class GenerateRandomSeedRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GenerateRandomSeedRequest) */ {
 public:
  GenerateRandomSeedRequest();
  virtual ~GenerateRandomSeedRequest();

  GenerateRandomSeedRequest(const GenerateRandomSeedRequest& from);

  inline GenerateRandomSeedRequest& operator=(const GenerateRandomSeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GenerateRandomSeedRequest(GenerateRandomSeedRequest&& from) noexcept
    : GenerateRandomSeedRequest() {
    *this = ::std::move(from);
  }

  inline GenerateRandomSeedRequest& operator=(GenerateRandomSeedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GenerateRandomSeedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenerateRandomSeedRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateRandomSeedRequest*>(
               &_GenerateRandomSeedRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(GenerateRandomSeedRequest* other);
  friend void swap(GenerateRandomSeedRequest& a, GenerateRandomSeedRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GenerateRandomSeedRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GenerateRandomSeedRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GenerateRandomSeedRequest& from);
  void MergeFrom(const GenerateRandomSeedRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GenerateRandomSeedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // bytes parent_seed = 2;
  void clear_parent_seed();
  static const int kParentSeedFieldNumber = 2;
  const ::std::string& parent_seed() const;
  void set_parent_seed(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_seed(::std::string&& value);
  #endif
  void set_parent_seed(const char* value);
  void set_parent_seed(const void* value, size_t size);
  ::std::string* mutable_parent_seed();
  ::std::string* release_parent_seed();
  void set_allocated_parent_seed(::std::string* parent_seed);

  // bytes ancestor_hash = 3;
  void clear_ancestor_hash();
  static const int kAncestorHashFieldNumber = 3;
  const ::std::string& ancestor_hash() const;
  void set_ancestor_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_ancestor_hash(::std::string&& value);
  #endif
  void set_ancestor_hash(const char* value);
  void set_ancestor_hash(const void* value, size_t size);
  ::std::string* mutable_ancestor_hash();
  ::std::string* release_ancestor_hash();
  void set_allocated_ancestor_hash(::std::string* ancestor_hash);

  // @@protoc_insertion_point(class_scope:rpcpb.GenerateRandomSeedRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr parent_seed_;
  ::google::protobuf::internal::ArenaStringPtr ancestor_hash_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGenerateRandomSeedRequestImpl();
};
// -------------------------------------------------------------------

class GenerateRandomSeedResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GenerateRandomSeedResponse) */ {
 public:
  GenerateRandomSeedResponse();
  virtual ~GenerateRandomSeedResponse();

  GenerateRandomSeedResponse(const GenerateRandomSeedResponse& from);

  inline GenerateRandomSeedResponse& operator=(const GenerateRandomSeedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GenerateRandomSeedResponse(GenerateRandomSeedResponse&& from) noexcept
    : GenerateRandomSeedResponse() {
    *this = ::std::move(from);
  }

  inline GenerateRandomSeedResponse& operator=(GenerateRandomSeedResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GenerateRandomSeedResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenerateRandomSeedResponse* internal_default_instance() {
    return reinterpret_cast<const GenerateRandomSeedResponse*>(
               &_GenerateRandomSeedResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(GenerateRandomSeedResponse* other);
  friend void swap(GenerateRandomSeedResponse& a, GenerateRandomSeedResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GenerateRandomSeedResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GenerateRandomSeedResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GenerateRandomSeedResponse& from);
  void MergeFrom(const GenerateRandomSeedResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GenerateRandomSeedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes vrf_seed = 1;
  void clear_vrf_seed();
  static const int kVrfSeedFieldNumber = 1;
  const ::std::string& vrf_seed() const;
  void set_vrf_seed(const ::std::string& value);
  #if LANG_CXX11
  void set_vrf_seed(::std::string&& value);
  #endif
  void set_vrf_seed(const char* value);
  void set_vrf_seed(const void* value, size_t size);
  ::std::string* mutable_vrf_seed();
  ::std::string* release_vrf_seed();
  void set_allocated_vrf_seed(::std::string* vrf_seed);

  // bytes vrf_proof = 2;
  void clear_vrf_proof();
  static const int kVrfProofFieldNumber = 2;
  const ::std::string& vrf_proof() const;
  void set_vrf_proof(const ::std::string& value);
  #if LANG_CXX11
  void set_vrf_proof(::std::string&& value);
  #endif
  void set_vrf_proof(const char* value);
  void set_vrf_proof(const void* value, size_t size);
  ::std::string* mutable_vrf_proof();
  ::std::string* release_vrf_proof();
  void set_allocated_vrf_proof(::std::string* vrf_proof);

  // @@protoc_insertion_point(class_scope:rpcpb.GenerateRandomSeedResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vrf_seed_;
  ::google::protobuf::internal::ArenaStringPtr vrf_proof_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGenerateRandomSeedResponseImpl();
};
// -------------------------------------------------------------------

class SignTransactionPassphraseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.SignTransactionPassphraseRequest) */ {
 public:
  SignTransactionPassphraseRequest();
  virtual ~SignTransactionPassphraseRequest();

  SignTransactionPassphraseRequest(const SignTransactionPassphraseRequest& from);

  inline SignTransactionPassphraseRequest& operator=(const SignTransactionPassphraseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignTransactionPassphraseRequest(SignTransactionPassphraseRequest&& from) noexcept
    : SignTransactionPassphraseRequest() {
    *this = ::std::move(from);
  }

  inline SignTransactionPassphraseRequest& operator=(SignTransactionPassphraseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignTransactionPassphraseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignTransactionPassphraseRequest* internal_default_instance() {
    return reinterpret_cast<const SignTransactionPassphraseRequest*>(
               &_SignTransactionPassphraseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(SignTransactionPassphraseRequest* other);
  friend void swap(SignTransactionPassphraseRequest& a, SignTransactionPassphraseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignTransactionPassphraseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SignTransactionPassphraseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignTransactionPassphraseRequest& from);
  void MergeFrom(const SignTransactionPassphraseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignTransactionPassphraseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string passphrase = 2;
  void clear_passphrase();
  static const int kPassphraseFieldNumber = 2;
  const ::std::string& passphrase() const;
  void set_passphrase(const ::std::string& value);
  #if LANG_CXX11
  void set_passphrase(::std::string&& value);
  #endif
  void set_passphrase(const char* value);
  void set_passphrase(const char* value, size_t size);
  ::std::string* mutable_passphrase();
  ::std::string* release_passphrase();
  void set_allocated_passphrase(::std::string* passphrase);

  // .rpcpb.TransactionRequest transaction = 1;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  const ::rpcpb::TransactionRequest& transaction() const;
  ::rpcpb::TransactionRequest* release_transaction();
  ::rpcpb::TransactionRequest* mutable_transaction();
  void set_allocated_transaction(::rpcpb::TransactionRequest* transaction);

  // @@protoc_insertion_point(class_scope:rpcpb.SignTransactionPassphraseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr passphrase_;
  ::rpcpb::TransactionRequest* transaction_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsSignTransactionPassphraseRequestImpl();
};
// -------------------------------------------------------------------

class SignTransactionPassphraseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.SignTransactionPassphraseResponse) */ {
 public:
  SignTransactionPassphraseResponse();
  virtual ~SignTransactionPassphraseResponse();

  SignTransactionPassphraseResponse(const SignTransactionPassphraseResponse& from);

  inline SignTransactionPassphraseResponse& operator=(const SignTransactionPassphraseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignTransactionPassphraseResponse(SignTransactionPassphraseResponse&& from) noexcept
    : SignTransactionPassphraseResponse() {
    *this = ::std::move(from);
  }

  inline SignTransactionPassphraseResponse& operator=(SignTransactionPassphraseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignTransactionPassphraseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignTransactionPassphraseResponse* internal_default_instance() {
    return reinterpret_cast<const SignTransactionPassphraseResponse*>(
               &_SignTransactionPassphraseResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(SignTransactionPassphraseResponse* other);
  friend void swap(SignTransactionPassphraseResponse& a, SignTransactionPassphraseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignTransactionPassphraseResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SignTransactionPassphraseResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignTransactionPassphraseResponse& from);
  void MergeFrom(const SignTransactionPassphraseResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignTransactionPassphraseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:rpcpb.SignTransactionPassphraseResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsSignTransactionPassphraseResponseImpl();
};
// -------------------------------------------------------------------

class SendTransactionPassphraseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.SendTransactionPassphraseRequest) */ {
 public:
  SendTransactionPassphraseRequest();
  virtual ~SendTransactionPassphraseRequest();

  SendTransactionPassphraseRequest(const SendTransactionPassphraseRequest& from);

  inline SendTransactionPassphraseRequest& operator=(const SendTransactionPassphraseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendTransactionPassphraseRequest(SendTransactionPassphraseRequest&& from) noexcept
    : SendTransactionPassphraseRequest() {
    *this = ::std::move(from);
  }

  inline SendTransactionPassphraseRequest& operator=(SendTransactionPassphraseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendTransactionPassphraseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendTransactionPassphraseRequest* internal_default_instance() {
    return reinterpret_cast<const SendTransactionPassphraseRequest*>(
               &_SendTransactionPassphraseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(SendTransactionPassphraseRequest* other);
  friend void swap(SendTransactionPassphraseRequest& a, SendTransactionPassphraseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendTransactionPassphraseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SendTransactionPassphraseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SendTransactionPassphraseRequest& from);
  void MergeFrom(const SendTransactionPassphraseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SendTransactionPassphraseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string passphrase = 2;
  void clear_passphrase();
  static const int kPassphraseFieldNumber = 2;
  const ::std::string& passphrase() const;
  void set_passphrase(const ::std::string& value);
  #if LANG_CXX11
  void set_passphrase(::std::string&& value);
  #endif
  void set_passphrase(const char* value);
  void set_passphrase(const char* value, size_t size);
  ::std::string* mutable_passphrase();
  ::std::string* release_passphrase();
  void set_allocated_passphrase(::std::string* passphrase);

  // .rpcpb.TransactionRequest transaction = 1;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  const ::rpcpb::TransactionRequest& transaction() const;
  ::rpcpb::TransactionRequest* release_transaction();
  ::rpcpb::TransactionRequest* mutable_transaction();
  void set_allocated_transaction(::rpcpb::TransactionRequest* transaction);

  // @@protoc_insertion_point(class_scope:rpcpb.SendTransactionPassphraseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr passphrase_;
  ::rpcpb::TransactionRequest* transaction_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsSendTransactionPassphraseRequestImpl();
};
// -------------------------------------------------------------------

class GasPriceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GasPriceResponse) */ {
 public:
  GasPriceResponse();
  virtual ~GasPriceResponse();

  GasPriceResponse(const GasPriceResponse& from);

  inline GasPriceResponse& operator=(const GasPriceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GasPriceResponse(GasPriceResponse&& from) noexcept
    : GasPriceResponse() {
    *this = ::std::move(from);
  }

  inline GasPriceResponse& operator=(GasPriceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GasPriceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GasPriceResponse* internal_default_instance() {
    return reinterpret_cast<const GasPriceResponse*>(
               &_GasPriceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(GasPriceResponse* other);
  friend void swap(GasPriceResponse& a, GasPriceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GasPriceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GasPriceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GasPriceResponse& from);
  void MergeFrom(const GasPriceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GasPriceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string gas_price = 1;
  void clear_gas_price();
  static const int kGasPriceFieldNumber = 1;
  const ::std::string& gas_price() const;
  void set_gas_price(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_price(::std::string&& value);
  #endif
  void set_gas_price(const char* value);
  void set_gas_price(const char* value, size_t size);
  ::std::string* mutable_gas_price();
  ::std::string* release_gas_price();
  void set_allocated_gas_price(::std::string* gas_price);

  // @@protoc_insertion_point(class_scope:rpcpb.GasPriceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr gas_price_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGasPriceResponseImpl();
};
// -------------------------------------------------------------------

class HashRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.HashRequest) */ {
 public:
  HashRequest();
  virtual ~HashRequest();

  HashRequest(const HashRequest& from);

  inline HashRequest& operator=(const HashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HashRequest(HashRequest&& from) noexcept
    : HashRequest() {
    *this = ::std::move(from);
  }

  inline HashRequest& operator=(HashRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HashRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HashRequest* internal_default_instance() {
    return reinterpret_cast<const HashRequest*>(
               &_HashRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(HashRequest* other);
  friend void swap(HashRequest& a, HashRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HashRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  HashRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HashRequest& from);
  void MergeFrom(const HashRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HashRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:rpcpb.HashRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsHashRequestImpl();
};
// -------------------------------------------------------------------

class GasResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GasResponse) */ {
 public:
  GasResponse();
  virtual ~GasResponse();

  GasResponse(const GasResponse& from);

  inline GasResponse& operator=(const GasResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GasResponse(GasResponse&& from) noexcept
    : GasResponse() {
    *this = ::std::move(from);
  }

  inline GasResponse& operator=(GasResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GasResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GasResponse* internal_default_instance() {
    return reinterpret_cast<const GasResponse*>(
               &_GasResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(GasResponse* other);
  friend void swap(GasResponse& a, GasResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GasResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GasResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GasResponse& from);
  void MergeFrom(const GasResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GasResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string gas = 1;
  void clear_gas();
  static const int kGasFieldNumber = 1;
  const ::std::string& gas() const;
  void set_gas(const ::std::string& value);
  #if LANG_CXX11
  void set_gas(::std::string&& value);
  #endif
  void set_gas(const char* value);
  void set_gas(const char* value, size_t size);
  ::std::string* mutable_gas();
  ::std::string* release_gas();
  void set_allocated_gas(::std::string* gas);

  // string err = 2;
  void clear_err();
  static const int kErrFieldNumber = 2;
  const ::std::string& err() const;
  void set_err(const ::std::string& value);
  #if LANG_CXX11
  void set_err(::std::string&& value);
  #endif
  void set_err(const char* value);
  void set_err(const char* value, size_t size);
  ::std::string* mutable_err();
  ::std::string* release_err();
  void set_allocated_err(::std::string* err);

  // @@protoc_insertion_point(class_scope:rpcpb.GasResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr gas_;
  ::google::protobuf::internal::ArenaStringPtr err_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGasResponseImpl();
};
// -------------------------------------------------------------------

class EventsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.EventsResponse) */ {
 public:
  EventsResponse();
  virtual ~EventsResponse();

  EventsResponse(const EventsResponse& from);

  inline EventsResponse& operator=(const EventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventsResponse(EventsResponse&& from) noexcept
    : EventsResponse() {
    *this = ::std::move(from);
  }

  inline EventsResponse& operator=(EventsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventsResponse* internal_default_instance() {
    return reinterpret_cast<const EventsResponse*>(
               &_EventsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(EventsResponse* other);
  friend void swap(EventsResponse& a, EventsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  EventsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EventsResponse& from);
  void MergeFrom(const EventsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EventsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rpcpb.Event events = 1;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 1;
  const ::rpcpb::Event& events(int index) const;
  ::rpcpb::Event* mutable_events(int index);
  ::rpcpb::Event* add_events();
  ::google::protobuf::RepeatedPtrField< ::rpcpb::Event >*
      mutable_events();
  const ::google::protobuf::RepeatedPtrField< ::rpcpb::Event >&
      events() const;

  // @@protoc_insertion_point(class_scope:rpcpb.EventsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::rpcpb::Event > events_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsEventsResponseImpl();
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const PROTOBUF_FINAL { return New(NULL); }

  Event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string topic = 1;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // string data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:rpcpb.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsEventImpl();
};
// -------------------------------------------------------------------

class PprofRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.PprofRequest) */ {
 public:
  PprofRequest();
  virtual ~PprofRequest();

  PprofRequest(const PprofRequest& from);

  inline PprofRequest& operator=(const PprofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PprofRequest(PprofRequest&& from) noexcept
    : PprofRequest() {
    *this = ::std::move(from);
  }

  inline PprofRequest& operator=(PprofRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PprofRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PprofRequest* internal_default_instance() {
    return reinterpret_cast<const PprofRequest*>(
               &_PprofRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(PprofRequest* other);
  friend void swap(PprofRequest& a, PprofRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PprofRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PprofRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PprofRequest& from);
  void MergeFrom(const PprofRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PprofRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string listen = 1;
  void clear_listen();
  static const int kListenFieldNumber = 1;
  const ::std::string& listen() const;
  void set_listen(const ::std::string& value);
  #if LANG_CXX11
  void set_listen(::std::string&& value);
  #endif
  void set_listen(const char* value);
  void set_listen(const char* value, size_t size);
  ::std::string* mutable_listen();
  ::std::string* release_listen();
  void set_allocated_listen(::std::string* listen);

  // @@protoc_insertion_point(class_scope:rpcpb.PprofRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr listen_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsPprofRequestImpl();
};
// -------------------------------------------------------------------

class PprofResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.PprofResponse) */ {
 public:
  PprofResponse();
  virtual ~PprofResponse();

  PprofResponse(const PprofResponse& from);

  inline PprofResponse& operator=(const PprofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PprofResponse(PprofResponse&& from) noexcept
    : PprofResponse() {
    *this = ::std::move(from);
  }

  inline PprofResponse& operator=(PprofResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PprofResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PprofResponse* internal_default_instance() {
    return reinterpret_cast<const PprofResponse*>(
               &_PprofResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(PprofResponse* other);
  friend void swap(PprofResponse& a, PprofResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PprofResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PprofResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PprofResponse& from);
  void MergeFrom(const PprofResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PprofResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:rpcpb.PprofResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool result_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsPprofResponseImpl();
};
// -------------------------------------------------------------------

class GetConfigResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.GetConfigResponse) */ {
 public:
  GetConfigResponse();
  virtual ~GetConfigResponse();

  GetConfigResponse(const GetConfigResponse& from);

  inline GetConfigResponse& operator=(const GetConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetConfigResponse(GetConfigResponse&& from) noexcept
    : GetConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetConfigResponse& operator=(GetConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetConfigResponse*>(
               &_GetConfigResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(GetConfigResponse* other);
  friend void swap(GetConfigResponse& a, GetConfigResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetConfigResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetConfigResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetConfigResponse& from);
  void MergeFrom(const GetConfigResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .nebletpb.Config config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::nebletpb::Config& config() const;
  ::nebletpb::Config* release_config();
  ::nebletpb::Config* mutable_config();
  void set_allocated_config(::nebletpb::Config* config);

  // @@protoc_insertion_point(class_scope:rpcpb.GetConfigResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::nebletpb::Config* config_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsGetConfigResponseImpl();
};
// -------------------------------------------------------------------

class NVMDeployRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.NVMDeployRequest) */ {
 public:
  NVMDeployRequest();
  virtual ~NVMDeployRequest();

  NVMDeployRequest(const NVMDeployRequest& from);

  inline NVMDeployRequest& operator=(const NVMDeployRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NVMDeployRequest(NVMDeployRequest&& from) noexcept
    : NVMDeployRequest() {
    *this = ::std::move(from);
  }

  inline NVMDeployRequest& operator=(NVMDeployRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NVMDeployRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NVMDeployRequest* internal_default_instance() {
    return reinterpret_cast<const NVMDeployRequest*>(
               &_NVMDeployRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(NVMDeployRequest* other);
  friend void swap(NVMDeployRequest& a, NVMDeployRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NVMDeployRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NVMDeployRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NVMDeployRequest& from);
  void MergeFrom(const NVMDeployRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NVMDeployRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string script_src = 1;
  void clear_script_src();
  static const int kScriptSrcFieldNumber = 1;
  const ::std::string& script_src() const;
  void set_script_src(const ::std::string& value);
  #if LANG_CXX11
  void set_script_src(::std::string&& value);
  #endif
  void set_script_src(const char* value);
  void set_script_src(const char* value, size_t size);
  ::std::string* mutable_script_src();
  ::std::string* release_script_src();
  void set_allocated_script_src(::std::string* script_src);

  // string from_addr = 2;
  void clear_from_addr();
  static const int kFromAddrFieldNumber = 2;
  const ::std::string& from_addr() const;
  void set_from_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_from_addr(::std::string&& value);
  #endif
  void set_from_addr(const char* value);
  void set_from_addr(const char* value, size_t size);
  ::std::string* mutable_from_addr();
  ::std::string* release_from_addr();
  void set_allocated_from_addr(::std::string* from_addr);

  // string type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // int64 block_height = 3;
  void clear_block_height();
  static const int kBlockHeightFieldNumber = 3;
  ::google::protobuf::int64 block_height() const;
  void set_block_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:rpcpb.NVMDeployRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr script_src_;
  ::google::protobuf::internal::ArenaStringPtr from_addr_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::int64 block_height_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsNVMDeployRequestImpl();
};
// -------------------------------------------------------------------

class NVMDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.NVMDataRequest) */ {
 public:
  NVMDataRequest();
  virtual ~NVMDataRequest();

  NVMDataRequest(const NVMDataRequest& from);

  inline NVMDataRequest& operator=(const NVMDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NVMDataRequest(NVMDataRequest&& from) noexcept
    : NVMDataRequest() {
    *this = ::std::move(from);
  }

  inline NVMDataRequest& operator=(NVMDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NVMDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NVMDataRequest* internal_default_instance() {
    return reinterpret_cast<const NVMDataRequest*>(
               &_NVMDataRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(NVMDataRequest* other);
  friend void swap(NVMDataRequest& a, NVMDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NVMDataRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NVMDataRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NVMDataRequest& from);
  void MergeFrom(const NVMDataRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NVMDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string request_type = 1;
  void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  const ::std::string& request_type() const;
  void set_request_type(const ::std::string& value);
  #if LANG_CXX11
  void set_request_type(::std::string&& value);
  #endif
  void set_request_type(const char* value);
  void set_request_type(const char* value, size_t size);
  ::std::string* mutable_request_type();
  ::std::string* release_request_type();
  void set_allocated_request_type(::std::string* request_type);

  // string script_src = 2;
  void clear_script_src();
  static const int kScriptSrcFieldNumber = 2;
  const ::std::string& script_src() const;
  void set_script_src(const ::std::string& value);
  #if LANG_CXX11
  void set_script_src(::std::string&& value);
  #endif
  void set_script_src(const char* value);
  void set_script_src(const char* value, size_t size);
  ::std::string* mutable_script_src();
  ::std::string* release_script_src();
  void set_allocated_script_src(::std::string* script_src);

  // string function_name = 3;
  void clear_function_name();
  static const int kFunctionNameFieldNumber = 3;
  const ::std::string& function_name() const;
  void set_function_name(const ::std::string& value);
  #if LANG_CXX11
  void set_function_name(::std::string&& value);
  #endif
  void set_function_name(const char* value);
  void set_function_name(const char* value, size_t size);
  ::std::string* mutable_function_name();
  ::std::string* release_function_name();
  void set_allocated_function_name(::std::string* function_name);

  // string contract_addr = 4;
  void clear_contract_addr();
  static const int kContractAddrFieldNumber = 4;
  const ::std::string& contract_addr() const;
  void set_contract_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_contract_addr(::std::string&& value);
  #endif
  void set_contract_addr(const char* value);
  void set_contract_addr(const char* value, size_t size);
  ::std::string* mutable_contract_addr();
  ::std::string* release_contract_addr();
  void set_allocated_contract_addr(::std::string* contract_addr);

  // string extra_data = 5;
  void clear_extra_data();
  static const int kExtraDataFieldNumber = 5;
  const ::std::string& extra_data() const;
  void set_extra_data(const ::std::string& value);
  #if LANG_CXX11
  void set_extra_data(::std::string&& value);
  #endif
  void set_extra_data(const char* value);
  void set_extra_data(const char* value, size_t size);
  ::std::string* mutable_extra_data();
  ::std::string* release_extra_data();
  void set_allocated_extra_data(::std::string* extra_data);

  // @@protoc_insertion_point(class_scope:rpcpb.NVMDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr request_type_;
  ::google::protobuf::internal::ArenaStringPtr script_src_;
  ::google::protobuf::internal::ArenaStringPtr function_name_;
  ::google::protobuf::internal::ArenaStringPtr contract_addr_;
  ::google::protobuf::internal::ArenaStringPtr extra_data_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsNVMDataRequestImpl();
};
// -------------------------------------------------------------------

class NVMResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rpcpb.NVMResponse) */ {
 public:
  NVMResponse();
  virtual ~NVMResponse();

  NVMResponse(const NVMResponse& from);

  inline NVMResponse& operator=(const NVMResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NVMResponse(NVMResponse&& from) noexcept
    : NVMResponse() {
    *this = ::std::move(from);
  }

  inline NVMResponse& operator=(NVMResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NVMResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NVMResponse* internal_default_instance() {
    return reinterpret_cast<const NVMResponse*>(
               &_NVMResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(NVMResponse* other);
  friend void swap(NVMResponse& a, NVMResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NVMResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NVMResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NVMResponse& from);
  void MergeFrom(const NVMResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NVMResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // int32 result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpcpb.NVMResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::int32 result_;
  mutable int _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
  friend void ::protobuf_rpc_2eproto::InitDefaultsNVMResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SubscribeRequest

// repeated string topics = 1;
inline int SubscribeRequest::topics_size() const {
  return topics_.size();
}
inline void SubscribeRequest::clear_topics() {
  topics_.Clear();
}
inline const ::std::string& SubscribeRequest::topics(int index) const {
  // @@protoc_insertion_point(field_get:rpcpb.SubscribeRequest.topics)
  return topics_.Get(index);
}
inline ::std::string* SubscribeRequest::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:rpcpb.SubscribeRequest.topics)
  return topics_.Mutable(index);
}
inline void SubscribeRequest::set_topics(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rpcpb.SubscribeRequest.topics)
  topics_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SubscribeRequest::set_topics(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:rpcpb.SubscribeRequest.topics)
  topics_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SubscribeRequest::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpcpb.SubscribeRequest.topics)
}
inline void SubscribeRequest::set_topics(int index, const char* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SubscribeRequest.topics)
}
inline ::std::string* SubscribeRequest::add_topics() {
  // @@protoc_insertion_point(field_add_mutable:rpcpb.SubscribeRequest.topics)
  return topics_.Add();
}
inline void SubscribeRequest::add_topics(const ::std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpcpb.SubscribeRequest.topics)
}
#if LANG_CXX11
inline void SubscribeRequest::add_topics(::std::string&& value) {
  topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpcpb.SubscribeRequest.topics)
}
#endif
inline void SubscribeRequest::add_topics(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpcpb.SubscribeRequest.topics)
}
inline void SubscribeRequest::add_topics(const char* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpcpb.SubscribeRequest.topics)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SubscribeRequest::topics() const {
  // @@protoc_insertion_point(field_list:rpcpb.SubscribeRequest.topics)
  return topics_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SubscribeRequest::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:rpcpb.SubscribeRequest.topics)
  return &topics_;
}

// -------------------------------------------------------------------

// SubscribeResponse

// string topic = 1;
inline void SubscribeResponse::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubscribeResponse::topic() const {
  // @@protoc_insertion_point(field_get:rpcpb.SubscribeResponse.topic)
  return topic_.GetNoArena();
}
inline void SubscribeResponse::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SubscribeResponse.topic)
}
#if LANG_CXX11
inline void SubscribeResponse::set_topic(::std::string&& value) {
  
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SubscribeResponse.topic)
}
#endif
inline void SubscribeResponse::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SubscribeResponse.topic)
}
inline void SubscribeResponse::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SubscribeResponse.topic)
}
inline ::std::string* SubscribeResponse::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SubscribeResponse.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeResponse::release_topic() {
  // @@protoc_insertion_point(field_release:rpcpb.SubscribeResponse.topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeResponse::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SubscribeResponse.topic)
}

// string data = 2;
inline void SubscribeResponse::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SubscribeResponse::data() const {
  // @@protoc_insertion_point(field_get:rpcpb.SubscribeResponse.data)
  return data_.GetNoArena();
}
inline void SubscribeResponse::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SubscribeResponse.data)
}
#if LANG_CXX11
inline void SubscribeResponse::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SubscribeResponse.data)
}
#endif
inline void SubscribeResponse::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SubscribeResponse.data)
}
inline void SubscribeResponse::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SubscribeResponse.data)
}
inline ::std::string* SubscribeResponse::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SubscribeResponse.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeResponse::release_data() {
  // @@protoc_insertion_point(field_release:rpcpb.SubscribeResponse.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeResponse::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SubscribeResponse.data)
}

// -------------------------------------------------------------------

// NonParamsRequest

// -------------------------------------------------------------------

// NodeInfoResponse

// string id = 1;
inline void NodeInfoResponse::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfoResponse::id() const {
  // @@protoc_insertion_point(field_get:rpcpb.NodeInfoResponse.id)
  return id_.GetNoArena();
}
inline void NodeInfoResponse::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NodeInfoResponse.id)
}
#if LANG_CXX11
inline void NodeInfoResponse::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NodeInfoResponse.id)
}
#endif
inline void NodeInfoResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NodeInfoResponse.id)
}
inline void NodeInfoResponse::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NodeInfoResponse.id)
}
inline ::std::string* NodeInfoResponse::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NodeInfoResponse.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfoResponse::release_id() {
  // @@protoc_insertion_point(field_release:rpcpb.NodeInfoResponse.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfoResponse::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NodeInfoResponse.id)
}

// uint32 chain_id = 2;
inline void NodeInfoResponse::clear_chain_id() {
  chain_id_ = 0u;
}
inline ::google::protobuf::uint32 NodeInfoResponse::chain_id() const {
  // @@protoc_insertion_point(field_get:rpcpb.NodeInfoResponse.chain_id)
  return chain_id_;
}
inline void NodeInfoResponse::set_chain_id(::google::protobuf::uint32 value) {
  
  chain_id_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.NodeInfoResponse.chain_id)
}

// string coinbase = 3;
inline void NodeInfoResponse::clear_coinbase() {
  coinbase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfoResponse::coinbase() const {
  // @@protoc_insertion_point(field_get:rpcpb.NodeInfoResponse.coinbase)
  return coinbase_.GetNoArena();
}
inline void NodeInfoResponse::set_coinbase(const ::std::string& value) {
  
  coinbase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NodeInfoResponse.coinbase)
}
#if LANG_CXX11
inline void NodeInfoResponse::set_coinbase(::std::string&& value) {
  
  coinbase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NodeInfoResponse.coinbase)
}
#endif
inline void NodeInfoResponse::set_coinbase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  coinbase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NodeInfoResponse.coinbase)
}
inline void NodeInfoResponse::set_coinbase(const char* value, size_t size) {
  
  coinbase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NodeInfoResponse.coinbase)
}
inline ::std::string* NodeInfoResponse::mutable_coinbase() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NodeInfoResponse.coinbase)
  return coinbase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfoResponse::release_coinbase() {
  // @@protoc_insertion_point(field_release:rpcpb.NodeInfoResponse.coinbase)
  
  return coinbase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfoResponse::set_allocated_coinbase(::std::string* coinbase) {
  if (coinbase != NULL) {
    
  } else {
    
  }
  coinbase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coinbase);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NodeInfoResponse.coinbase)
}

// uint32 peer_count = 4;
inline void NodeInfoResponse::clear_peer_count() {
  peer_count_ = 0u;
}
inline ::google::protobuf::uint32 NodeInfoResponse::peer_count() const {
  // @@protoc_insertion_point(field_get:rpcpb.NodeInfoResponse.peer_count)
  return peer_count_;
}
inline void NodeInfoResponse::set_peer_count(::google::protobuf::uint32 value) {
  
  peer_count_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.NodeInfoResponse.peer_count)
}

// bool synchronized = 5;
inline void NodeInfoResponse::clear_synchronized() {
  synchronized_ = false;
}
inline bool NodeInfoResponse::synchronized() const {
  // @@protoc_insertion_point(field_get:rpcpb.NodeInfoResponse.synchronized)
  return synchronized_;
}
inline void NodeInfoResponse::set_synchronized(bool value) {
  
  synchronized_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.NodeInfoResponse.synchronized)
}

// int32 bucket_size = 6;
inline void NodeInfoResponse::clear_bucket_size() {
  bucket_size_ = 0;
}
inline ::google::protobuf::int32 NodeInfoResponse::bucket_size() const {
  // @@protoc_insertion_point(field_get:rpcpb.NodeInfoResponse.bucket_size)
  return bucket_size_;
}
inline void NodeInfoResponse::set_bucket_size(::google::protobuf::int32 value) {
  
  bucket_size_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.NodeInfoResponse.bucket_size)
}

// string protocol_version = 10;
inline void NodeInfoResponse::clear_protocol_version() {
  protocol_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfoResponse::protocol_version() const {
  // @@protoc_insertion_point(field_get:rpcpb.NodeInfoResponse.protocol_version)
  return protocol_version_.GetNoArena();
}
inline void NodeInfoResponse::set_protocol_version(const ::std::string& value) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NodeInfoResponse.protocol_version)
}
#if LANG_CXX11
inline void NodeInfoResponse::set_protocol_version(::std::string&& value) {
  
  protocol_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NodeInfoResponse.protocol_version)
}
#endif
inline void NodeInfoResponse::set_protocol_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NodeInfoResponse.protocol_version)
}
inline void NodeInfoResponse::set_protocol_version(const char* value, size_t size) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NodeInfoResponse.protocol_version)
}
inline ::std::string* NodeInfoResponse::mutable_protocol_version() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NodeInfoResponse.protocol_version)
  return protocol_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfoResponse::release_protocol_version() {
  // @@protoc_insertion_point(field_release:rpcpb.NodeInfoResponse.protocol_version)
  
  return protocol_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfoResponse::set_allocated_protocol_version(::std::string* protocol_version) {
  if (protocol_version != NULL) {
    
  } else {
    
  }
  protocol_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_version);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NodeInfoResponse.protocol_version)
}

// repeated .rpcpb.RouteTable route_table = 11;
inline int NodeInfoResponse::route_table_size() const {
  return route_table_.size();
}
inline void NodeInfoResponse::clear_route_table() {
  route_table_.Clear();
}
inline const ::rpcpb::RouteTable& NodeInfoResponse::route_table(int index) const {
  // @@protoc_insertion_point(field_get:rpcpb.NodeInfoResponse.route_table)
  return route_table_.Get(index);
}
inline ::rpcpb::RouteTable* NodeInfoResponse::mutable_route_table(int index) {
  // @@protoc_insertion_point(field_mutable:rpcpb.NodeInfoResponse.route_table)
  return route_table_.Mutable(index);
}
inline ::rpcpb::RouteTable* NodeInfoResponse::add_route_table() {
  // @@protoc_insertion_point(field_add:rpcpb.NodeInfoResponse.route_table)
  return route_table_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::rpcpb::RouteTable >*
NodeInfoResponse::mutable_route_table() {
  // @@protoc_insertion_point(field_mutable_list:rpcpb.NodeInfoResponse.route_table)
  return &route_table_;
}
inline const ::google::protobuf::RepeatedPtrField< ::rpcpb::RouteTable >&
NodeInfoResponse::route_table() const {
  // @@protoc_insertion_point(field_list:rpcpb.NodeInfoResponse.route_table)
  return route_table_;
}

// -------------------------------------------------------------------

// RouteTable

// string id = 1;
inline void RouteTable::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteTable::id() const {
  // @@protoc_insertion_point(field_get:rpcpb.RouteTable.id)
  return id_.GetNoArena();
}
inline void RouteTable::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.RouteTable.id)
}
#if LANG_CXX11
inline void RouteTable::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.RouteTable.id)
}
#endif
inline void RouteTable::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.RouteTable.id)
}
inline void RouteTable::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.RouteTable.id)
}
inline ::std::string* RouteTable::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.RouteTable.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteTable::release_id() {
  // @@protoc_insertion_point(field_release:rpcpb.RouteTable.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteTable::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.RouteTable.id)
}

// repeated string address = 2;
inline int RouteTable::address_size() const {
  return address_.size();
}
inline void RouteTable::clear_address() {
  address_.Clear();
}
inline const ::std::string& RouteTable::address(int index) const {
  // @@protoc_insertion_point(field_get:rpcpb.RouteTable.address)
  return address_.Get(index);
}
inline ::std::string* RouteTable::mutable_address(int index) {
  // @@protoc_insertion_point(field_mutable:rpcpb.RouteTable.address)
  return address_.Mutable(index);
}
inline void RouteTable::set_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rpcpb.RouteTable.address)
  address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RouteTable::set_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:rpcpb.RouteTable.address)
  address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RouteTable::set_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpcpb.RouteTable.address)
}
inline void RouteTable::set_address(int index, const char* value, size_t size) {
  address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpcpb.RouteTable.address)
}
inline ::std::string* RouteTable::add_address() {
  // @@protoc_insertion_point(field_add_mutable:rpcpb.RouteTable.address)
  return address_.Add();
}
inline void RouteTable::add_address(const ::std::string& value) {
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpcpb.RouteTable.address)
}
#if LANG_CXX11
inline void RouteTable::add_address(::std::string&& value) {
  address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpcpb.RouteTable.address)
}
#endif
inline void RouteTable::add_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpcpb.RouteTable.address)
}
inline void RouteTable::add_address(const char* value, size_t size) {
  address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpcpb.RouteTable.address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RouteTable::address() const {
  // @@protoc_insertion_point(field_list:rpcpb.RouteTable.address)
  return address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RouteTable::mutable_address() {
  // @@protoc_insertion_point(field_mutable_list:rpcpb.RouteTable.address)
  return &address_;
}

// -------------------------------------------------------------------

// GetNebStateResponse

// uint32 chain_id = 1;
inline void GetNebStateResponse::clear_chain_id() {
  chain_id_ = 0u;
}
inline ::google::protobuf::uint32 GetNebStateResponse::chain_id() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetNebStateResponse.chain_id)
  return chain_id_;
}
inline void GetNebStateResponse::set_chain_id(::google::protobuf::uint32 value) {
  
  chain_id_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.GetNebStateResponse.chain_id)
}

// string tail = 2;
inline void GetNebStateResponse::clear_tail() {
  tail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetNebStateResponse::tail() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetNebStateResponse.tail)
  return tail_.GetNoArena();
}
inline void GetNebStateResponse::set_tail(const ::std::string& value) {
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GetNebStateResponse.tail)
}
#if LANG_CXX11
inline void GetNebStateResponse::set_tail(::std::string&& value) {
  
  tail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GetNebStateResponse.tail)
}
#endif
inline void GetNebStateResponse::set_tail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GetNebStateResponse.tail)
}
inline void GetNebStateResponse::set_tail(const char* value, size_t size) {
  
  tail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetNebStateResponse.tail)
}
inline ::std::string* GetNebStateResponse::mutable_tail() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GetNebStateResponse.tail)
  return tail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetNebStateResponse::release_tail() {
  // @@protoc_insertion_point(field_release:rpcpb.GetNebStateResponse.tail)
  
  return tail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetNebStateResponse::set_allocated_tail(::std::string* tail) {
  if (tail != NULL) {
    
  } else {
    
  }
  tail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tail);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetNebStateResponse.tail)
}

// string lib = 3;
inline void GetNebStateResponse::clear_lib() {
  lib_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetNebStateResponse::lib() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetNebStateResponse.lib)
  return lib_.GetNoArena();
}
inline void GetNebStateResponse::set_lib(const ::std::string& value) {
  
  lib_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GetNebStateResponse.lib)
}
#if LANG_CXX11
inline void GetNebStateResponse::set_lib(::std::string&& value) {
  
  lib_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GetNebStateResponse.lib)
}
#endif
inline void GetNebStateResponse::set_lib(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lib_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GetNebStateResponse.lib)
}
inline void GetNebStateResponse::set_lib(const char* value, size_t size) {
  
  lib_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetNebStateResponse.lib)
}
inline ::std::string* GetNebStateResponse::mutable_lib() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GetNebStateResponse.lib)
  return lib_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetNebStateResponse::release_lib() {
  // @@protoc_insertion_point(field_release:rpcpb.GetNebStateResponse.lib)
  
  return lib_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetNebStateResponse::set_allocated_lib(::std::string* lib) {
  if (lib != NULL) {
    
  } else {
    
  }
  lib_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lib);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetNebStateResponse.lib)
}

// uint64 height = 4;
inline void GetNebStateResponse::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetNebStateResponse::height() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetNebStateResponse.height)
  return height_;
}
inline void GetNebStateResponse::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.GetNebStateResponse.height)
}

// string protocol_version = 6;
inline void GetNebStateResponse::clear_protocol_version() {
  protocol_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetNebStateResponse::protocol_version() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetNebStateResponse.protocol_version)
  return protocol_version_.GetNoArena();
}
inline void GetNebStateResponse::set_protocol_version(const ::std::string& value) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GetNebStateResponse.protocol_version)
}
#if LANG_CXX11
inline void GetNebStateResponse::set_protocol_version(::std::string&& value) {
  
  protocol_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GetNebStateResponse.protocol_version)
}
#endif
inline void GetNebStateResponse::set_protocol_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GetNebStateResponse.protocol_version)
}
inline void GetNebStateResponse::set_protocol_version(const char* value, size_t size) {
  
  protocol_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetNebStateResponse.protocol_version)
}
inline ::std::string* GetNebStateResponse::mutable_protocol_version() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GetNebStateResponse.protocol_version)
  return protocol_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetNebStateResponse::release_protocol_version() {
  // @@protoc_insertion_point(field_release:rpcpb.GetNebStateResponse.protocol_version)
  
  return protocol_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetNebStateResponse::set_allocated_protocol_version(::std::string* protocol_version) {
  if (protocol_version != NULL) {
    
  } else {
    
  }
  protocol_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol_version);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetNebStateResponse.protocol_version)
}

// bool synchronized = 7;
inline void GetNebStateResponse::clear_synchronized() {
  synchronized_ = false;
}
inline bool GetNebStateResponse::synchronized() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetNebStateResponse.synchronized)
  return synchronized_;
}
inline void GetNebStateResponse::set_synchronized(bool value) {
  
  synchronized_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.GetNebStateResponse.synchronized)
}

// string version = 8;
inline void GetNebStateResponse::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetNebStateResponse::version() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetNebStateResponse.version)
  return version_.GetNoArena();
}
inline void GetNebStateResponse::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GetNebStateResponse.version)
}
#if LANG_CXX11
inline void GetNebStateResponse::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GetNebStateResponse.version)
}
#endif
inline void GetNebStateResponse::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GetNebStateResponse.version)
}
inline void GetNebStateResponse::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetNebStateResponse.version)
}
inline ::std::string* GetNebStateResponse::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GetNebStateResponse.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetNebStateResponse::release_version() {
  // @@protoc_insertion_point(field_release:rpcpb.GetNebStateResponse.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetNebStateResponse::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetNebStateResponse.version)
}

// -------------------------------------------------------------------

// AccountsResponse

// repeated string addresses = 1;
inline int AccountsResponse::addresses_size() const {
  return addresses_.size();
}
inline void AccountsResponse::clear_addresses() {
  addresses_.Clear();
}
inline const ::std::string& AccountsResponse::addresses(int index) const {
  // @@protoc_insertion_point(field_get:rpcpb.AccountsResponse.addresses)
  return addresses_.Get(index);
}
inline ::std::string* AccountsResponse::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:rpcpb.AccountsResponse.addresses)
  return addresses_.Mutable(index);
}
inline void AccountsResponse::set_addresses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rpcpb.AccountsResponse.addresses)
  addresses_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AccountsResponse::set_addresses(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:rpcpb.AccountsResponse.addresses)
  addresses_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AccountsResponse::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpcpb.AccountsResponse.addresses)
}
inline void AccountsResponse::set_addresses(int index, const char* value, size_t size) {
  addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpcpb.AccountsResponse.addresses)
}
inline ::std::string* AccountsResponse::add_addresses() {
  // @@protoc_insertion_point(field_add_mutable:rpcpb.AccountsResponse.addresses)
  return addresses_.Add();
}
inline void AccountsResponse::add_addresses(const ::std::string& value) {
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpcpb.AccountsResponse.addresses)
}
#if LANG_CXX11
inline void AccountsResponse::add_addresses(::std::string&& value) {
  addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpcpb.AccountsResponse.addresses)
}
#endif
inline void AccountsResponse::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpcpb.AccountsResponse.addresses)
}
inline void AccountsResponse::add_addresses(const char* value, size_t size) {
  addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpcpb.AccountsResponse.addresses)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AccountsResponse::addresses() const {
  // @@protoc_insertion_point(field_list:rpcpb.AccountsResponse.addresses)
  return addresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AccountsResponse::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:rpcpb.AccountsResponse.addresses)
  return &addresses_;
}

// -------------------------------------------------------------------

// GetAccountStateRequest

// string address = 1;
inline void GetAccountStateRequest::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountStateRequest::address() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetAccountStateRequest.address)
  return address_.GetNoArena();
}
inline void GetAccountStateRequest::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GetAccountStateRequest.address)
}
#if LANG_CXX11
inline void GetAccountStateRequest::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GetAccountStateRequest.address)
}
#endif
inline void GetAccountStateRequest::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GetAccountStateRequest.address)
}
inline void GetAccountStateRequest::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetAccountStateRequest.address)
}
inline ::std::string* GetAccountStateRequest::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GetAccountStateRequest.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountStateRequest::release_address() {
  // @@protoc_insertion_point(field_release:rpcpb.GetAccountStateRequest.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountStateRequest::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetAccountStateRequest.address)
}

// uint64 height = 2;
inline void GetAccountStateRequest::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetAccountStateRequest::height() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetAccountStateRequest.height)
  return height_;
}
inline void GetAccountStateRequest::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.GetAccountStateRequest.height)
}

// -------------------------------------------------------------------

// GetAccountStateResponse

// string balance = 1;
inline void GetAccountStateResponse::clear_balance() {
  balance_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountStateResponse::balance() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetAccountStateResponse.balance)
  return balance_.GetNoArena();
}
inline void GetAccountStateResponse::set_balance(const ::std::string& value) {
  
  balance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GetAccountStateResponse.balance)
}
#if LANG_CXX11
inline void GetAccountStateResponse::set_balance(::std::string&& value) {
  
  balance_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GetAccountStateResponse.balance)
}
#endif
inline void GetAccountStateResponse::set_balance(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  balance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GetAccountStateResponse.balance)
}
inline void GetAccountStateResponse::set_balance(const char* value, size_t size) {
  
  balance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetAccountStateResponse.balance)
}
inline ::std::string* GetAccountStateResponse::mutable_balance() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GetAccountStateResponse.balance)
  return balance_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountStateResponse::release_balance() {
  // @@protoc_insertion_point(field_release:rpcpb.GetAccountStateResponse.balance)
  
  return balance_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountStateResponse::set_allocated_balance(::std::string* balance) {
  if (balance != NULL) {
    
  } else {
    
  }
  balance_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), balance);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetAccountStateResponse.balance)
}

// uint64 nonce = 2;
inline void GetAccountStateResponse::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetAccountStateResponse::nonce() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetAccountStateResponse.nonce)
  return nonce_;
}
inline void GetAccountStateResponse::set_nonce(::google::protobuf::uint64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.GetAccountStateResponse.nonce)
}

// uint32 type = 3;
inline void GetAccountStateResponse::clear_type() {
  type_ = 0u;
}
inline ::google::protobuf::uint32 GetAccountStateResponse::type() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetAccountStateResponse.type)
  return type_;
}
inline void GetAccountStateResponse::set_type(::google::protobuf::uint32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.GetAccountStateResponse.type)
}

// -------------------------------------------------------------------

// CallResponse

// string result = 1;
inline void CallResponse::clear_result() {
  result_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CallResponse::result() const {
  // @@protoc_insertion_point(field_get:rpcpb.CallResponse.result)
  return result_.GetNoArena();
}
inline void CallResponse::set_result(const ::std::string& value) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.CallResponse.result)
}
#if LANG_CXX11
inline void CallResponse::set_result(::std::string&& value) {
  
  result_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.CallResponse.result)
}
#endif
inline void CallResponse::set_result(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.CallResponse.result)
}
inline void CallResponse::set_result(const char* value, size_t size) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.CallResponse.result)
}
inline ::std::string* CallResponse::mutable_result() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.CallResponse.result)
  return result_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CallResponse::release_result() {
  // @@protoc_insertion_point(field_release:rpcpb.CallResponse.result)
  
  return result_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallResponse::set_allocated_result(::std::string* result) {
  if (result != NULL) {
    
  } else {
    
  }
  result_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), result);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.CallResponse.result)
}

// string execute_err = 2;
inline void CallResponse::clear_execute_err() {
  execute_err_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CallResponse::execute_err() const {
  // @@protoc_insertion_point(field_get:rpcpb.CallResponse.execute_err)
  return execute_err_.GetNoArena();
}
inline void CallResponse::set_execute_err(const ::std::string& value) {
  
  execute_err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.CallResponse.execute_err)
}
#if LANG_CXX11
inline void CallResponse::set_execute_err(::std::string&& value) {
  
  execute_err_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.CallResponse.execute_err)
}
#endif
inline void CallResponse::set_execute_err(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  execute_err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.CallResponse.execute_err)
}
inline void CallResponse::set_execute_err(const char* value, size_t size) {
  
  execute_err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.CallResponse.execute_err)
}
inline ::std::string* CallResponse::mutable_execute_err() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.CallResponse.execute_err)
  return execute_err_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CallResponse::release_execute_err() {
  // @@protoc_insertion_point(field_release:rpcpb.CallResponse.execute_err)
  
  return execute_err_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallResponse::set_allocated_execute_err(::std::string* execute_err) {
  if (execute_err != NULL) {
    
  } else {
    
  }
  execute_err_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), execute_err);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.CallResponse.execute_err)
}

// string estimate_gas = 3;
inline void CallResponse::clear_estimate_gas() {
  estimate_gas_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CallResponse::estimate_gas() const {
  // @@protoc_insertion_point(field_get:rpcpb.CallResponse.estimate_gas)
  return estimate_gas_.GetNoArena();
}
inline void CallResponse::set_estimate_gas(const ::std::string& value) {
  
  estimate_gas_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.CallResponse.estimate_gas)
}
#if LANG_CXX11
inline void CallResponse::set_estimate_gas(::std::string&& value) {
  
  estimate_gas_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.CallResponse.estimate_gas)
}
#endif
inline void CallResponse::set_estimate_gas(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  estimate_gas_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.CallResponse.estimate_gas)
}
inline void CallResponse::set_estimate_gas(const char* value, size_t size) {
  
  estimate_gas_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.CallResponse.estimate_gas)
}
inline ::std::string* CallResponse::mutable_estimate_gas() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.CallResponse.estimate_gas)
  return estimate_gas_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CallResponse::release_estimate_gas() {
  // @@protoc_insertion_point(field_release:rpcpb.CallResponse.estimate_gas)
  
  return estimate_gas_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallResponse::set_allocated_estimate_gas(::std::string* estimate_gas) {
  if (estimate_gas != NULL) {
    
  } else {
    
  }
  estimate_gas_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), estimate_gas);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.CallResponse.estimate_gas)
}

// -------------------------------------------------------------------

// ByBlockHeightRequest

// uint64 height = 1;
inline void ByBlockHeightRequest::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ByBlockHeightRequest::height() const {
  // @@protoc_insertion_point(field_get:rpcpb.ByBlockHeightRequest.height)
  return height_;
}
inline void ByBlockHeightRequest::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.ByBlockHeightRequest.height)
}

// -------------------------------------------------------------------

// GetDynastyResponse

// repeated string miners = 1;
inline int GetDynastyResponse::miners_size() const {
  return miners_.size();
}
inline void GetDynastyResponse::clear_miners() {
  miners_.Clear();
}
inline const ::std::string& GetDynastyResponse::miners(int index) const {
  // @@protoc_insertion_point(field_get:rpcpb.GetDynastyResponse.miners)
  return miners_.Get(index);
}
inline ::std::string* GetDynastyResponse::mutable_miners(int index) {
  // @@protoc_insertion_point(field_mutable:rpcpb.GetDynastyResponse.miners)
  return miners_.Mutable(index);
}
inline void GetDynastyResponse::set_miners(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rpcpb.GetDynastyResponse.miners)
  miners_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetDynastyResponse::set_miners(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:rpcpb.GetDynastyResponse.miners)
  miners_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetDynastyResponse::set_miners(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  miners_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:rpcpb.GetDynastyResponse.miners)
}
inline void GetDynastyResponse::set_miners(int index, const char* value, size_t size) {
  miners_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetDynastyResponse.miners)
}
inline ::std::string* GetDynastyResponse::add_miners() {
  // @@protoc_insertion_point(field_add_mutable:rpcpb.GetDynastyResponse.miners)
  return miners_.Add();
}
inline void GetDynastyResponse::add_miners(const ::std::string& value) {
  miners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:rpcpb.GetDynastyResponse.miners)
}
#if LANG_CXX11
inline void GetDynastyResponse::add_miners(::std::string&& value) {
  miners_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:rpcpb.GetDynastyResponse.miners)
}
#endif
inline void GetDynastyResponse::add_miners(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  miners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:rpcpb.GetDynastyResponse.miners)
}
inline void GetDynastyResponse::add_miners(const char* value, size_t size) {
  miners_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:rpcpb.GetDynastyResponse.miners)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetDynastyResponse::miners() const {
  // @@protoc_insertion_point(field_list:rpcpb.GetDynastyResponse.miners)
  return miners_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetDynastyResponse::mutable_miners() {
  // @@protoc_insertion_point(field_mutable_list:rpcpb.GetDynastyResponse.miners)
  return &miners_;
}

// -------------------------------------------------------------------

// TransactionRequest

// string from = 1;
inline void TransactionRequest::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionRequest::from() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionRequest.from)
  return from_.GetNoArena();
}
inline void TransactionRequest::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionRequest.from)
}
#if LANG_CXX11
inline void TransactionRequest::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionRequest.from)
}
#endif
inline void TransactionRequest::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionRequest.from)
}
inline void TransactionRequest::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionRequest.from)
}
inline ::std::string* TransactionRequest::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionRequest.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionRequest::release_from() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionRequest.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionRequest::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionRequest.from)
}

// string to = 2;
inline void TransactionRequest::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionRequest::to() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionRequest.to)
  return to_.GetNoArena();
}
inline void TransactionRequest::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionRequest.to)
}
#if LANG_CXX11
inline void TransactionRequest::set_to(::std::string&& value) {
  
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionRequest.to)
}
#endif
inline void TransactionRequest::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionRequest.to)
}
inline void TransactionRequest::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionRequest.to)
}
inline ::std::string* TransactionRequest::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionRequest.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionRequest::release_to() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionRequest.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionRequest::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionRequest.to)
}

// string value = 3;
inline void TransactionRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionRequest::value() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionRequest.value)
  return value_.GetNoArena();
}
inline void TransactionRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionRequest.value)
}
#if LANG_CXX11
inline void TransactionRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionRequest.value)
}
#endif
inline void TransactionRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionRequest.value)
}
inline void TransactionRequest::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionRequest.value)
}
inline ::std::string* TransactionRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionRequest::release_value() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionRequest::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionRequest.value)
}

// uint64 nonce = 4;
inline void TransactionRequest::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TransactionRequest::nonce() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionRequest.nonce)
  return nonce_;
}
inline void TransactionRequest::set_nonce(::google::protobuf::uint64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.TransactionRequest.nonce)
}

// string gas_price = 5;
inline void TransactionRequest::clear_gas_price() {
  gas_price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionRequest::gas_price() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionRequest.gas_price)
  return gas_price_.GetNoArena();
}
inline void TransactionRequest::set_gas_price(const ::std::string& value) {
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionRequest.gas_price)
}
#if LANG_CXX11
inline void TransactionRequest::set_gas_price(::std::string&& value) {
  
  gas_price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionRequest.gas_price)
}
#endif
inline void TransactionRequest::set_gas_price(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionRequest.gas_price)
}
inline void TransactionRequest::set_gas_price(const char* value, size_t size) {
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionRequest.gas_price)
}
inline ::std::string* TransactionRequest::mutable_gas_price() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionRequest.gas_price)
  return gas_price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionRequest::release_gas_price() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionRequest.gas_price)
  
  return gas_price_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionRequest::set_allocated_gas_price(::std::string* gas_price) {
  if (gas_price != NULL) {
    
  } else {
    
  }
  gas_price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_price);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionRequest.gas_price)
}

// string gas_limit = 6;
inline void TransactionRequest::clear_gas_limit() {
  gas_limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionRequest::gas_limit() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionRequest.gas_limit)
  return gas_limit_.GetNoArena();
}
inline void TransactionRequest::set_gas_limit(const ::std::string& value) {
  
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionRequest.gas_limit)
}
#if LANG_CXX11
inline void TransactionRequest::set_gas_limit(::std::string&& value) {
  
  gas_limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionRequest.gas_limit)
}
#endif
inline void TransactionRequest::set_gas_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionRequest.gas_limit)
}
inline void TransactionRequest::set_gas_limit(const char* value, size_t size) {
  
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionRequest.gas_limit)
}
inline ::std::string* TransactionRequest::mutable_gas_limit() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionRequest.gas_limit)
  return gas_limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionRequest::release_gas_limit() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionRequest.gas_limit)
  
  return gas_limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionRequest::set_allocated_gas_limit(::std::string* gas_limit) {
  if (gas_limit != NULL) {
    
  } else {
    
  }
  gas_limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_limit);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionRequest.gas_limit)
}

// .rpcpb.ContractRequest contract = 7;
inline bool TransactionRequest::has_contract() const {
  return this != internal_default_instance() && contract_ != NULL;
}
inline void TransactionRequest::clear_contract() {
  if (GetArenaNoVirtual() == NULL && contract_ != NULL) {
    delete contract_;
  }
  contract_ = NULL;
}
inline const ::rpcpb::ContractRequest& TransactionRequest::contract() const {
  const ::rpcpb::ContractRequest* p = contract_;
  // @@protoc_insertion_point(field_get:rpcpb.TransactionRequest.contract)
  return p != NULL ? *p : *reinterpret_cast<const ::rpcpb::ContractRequest*>(
      &::rpcpb::_ContractRequest_default_instance_);
}
inline ::rpcpb::ContractRequest* TransactionRequest::release_contract() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionRequest.contract)
  
  ::rpcpb::ContractRequest* temp = contract_;
  contract_ = NULL;
  return temp;
}
inline ::rpcpb::ContractRequest* TransactionRequest::mutable_contract() {
  
  if (contract_ == NULL) {
    contract_ = new ::rpcpb::ContractRequest;
  }
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionRequest.contract)
  return contract_;
}
inline void TransactionRequest::set_allocated_contract(::rpcpb::ContractRequest* contract) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contract_;
  }
  if (contract) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contract = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionRequest.contract)
}

// bytes binary = 10;
inline void TransactionRequest::clear_binary() {
  binary_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionRequest::binary() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionRequest.binary)
  return binary_.GetNoArena();
}
inline void TransactionRequest::set_binary(const ::std::string& value) {
  
  binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionRequest.binary)
}
#if LANG_CXX11
inline void TransactionRequest::set_binary(::std::string&& value) {
  
  binary_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionRequest.binary)
}
#endif
inline void TransactionRequest::set_binary(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionRequest.binary)
}
inline void TransactionRequest::set_binary(const void* value, size_t size) {
  
  binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionRequest.binary)
}
inline ::std::string* TransactionRequest::mutable_binary() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionRequest.binary)
  return binary_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionRequest::release_binary() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionRequest.binary)
  
  return binary_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionRequest::set_allocated_binary(::std::string* binary) {
  if (binary != NULL) {
    
  } else {
    
  }
  binary_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), binary);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionRequest.binary)
}

// string type = 20;
inline void TransactionRequest::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionRequest::type() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionRequest.type)
  return type_.GetNoArena();
}
inline void TransactionRequest::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionRequest.type)
}
#if LANG_CXX11
inline void TransactionRequest::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionRequest.type)
}
#endif
inline void TransactionRequest::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionRequest.type)
}
inline void TransactionRequest::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionRequest.type)
}
inline ::std::string* TransactionRequest::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionRequest.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionRequest::release_type() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionRequest.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionRequest::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionRequest.type)
}

// -------------------------------------------------------------------

// ContractRequest

// string source = 1;
inline void ContractRequest::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractRequest::source() const {
  // @@protoc_insertion_point(field_get:rpcpb.ContractRequest.source)
  return source_.GetNoArena();
}
inline void ContractRequest::set_source(const ::std::string& value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.ContractRequest.source)
}
#if LANG_CXX11
inline void ContractRequest::set_source(::std::string&& value) {
  
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.ContractRequest.source)
}
#endif
inline void ContractRequest::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.ContractRequest.source)
}
inline void ContractRequest::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.ContractRequest.source)
}
inline ::std::string* ContractRequest::mutable_source() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.ContractRequest.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractRequest::release_source() {
  // @@protoc_insertion_point(field_release:rpcpb.ContractRequest.source)
  
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractRequest::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.ContractRequest.source)
}

// string source_type = 2;
inline void ContractRequest::clear_source_type() {
  source_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractRequest::source_type() const {
  // @@protoc_insertion_point(field_get:rpcpb.ContractRequest.source_type)
  return source_type_.GetNoArena();
}
inline void ContractRequest::set_source_type(const ::std::string& value) {
  
  source_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.ContractRequest.source_type)
}
#if LANG_CXX11
inline void ContractRequest::set_source_type(::std::string&& value) {
  
  source_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.ContractRequest.source_type)
}
#endif
inline void ContractRequest::set_source_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.ContractRequest.source_type)
}
inline void ContractRequest::set_source_type(const char* value, size_t size) {
  
  source_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.ContractRequest.source_type)
}
inline ::std::string* ContractRequest::mutable_source_type() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.ContractRequest.source_type)
  return source_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractRequest::release_source_type() {
  // @@protoc_insertion_point(field_release:rpcpb.ContractRequest.source_type)
  
  return source_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractRequest::set_allocated_source_type(::std::string* source_type) {
  if (source_type != NULL) {
    
  } else {
    
  }
  source_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_type);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.ContractRequest.source_type)
}

// string function = 3;
inline void ContractRequest::clear_function() {
  function_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractRequest::function() const {
  // @@protoc_insertion_point(field_get:rpcpb.ContractRequest.function)
  return function_.GetNoArena();
}
inline void ContractRequest::set_function(const ::std::string& value) {
  
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.ContractRequest.function)
}
#if LANG_CXX11
inline void ContractRequest::set_function(::std::string&& value) {
  
  function_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.ContractRequest.function)
}
#endif
inline void ContractRequest::set_function(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.ContractRequest.function)
}
inline void ContractRequest::set_function(const char* value, size_t size) {
  
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.ContractRequest.function)
}
inline ::std::string* ContractRequest::mutable_function() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.ContractRequest.function)
  return function_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractRequest::release_function() {
  // @@protoc_insertion_point(field_release:rpcpb.ContractRequest.function)
  
  return function_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractRequest::set_allocated_function(::std::string* function) {
  if (function != NULL) {
    
  } else {
    
  }
  function_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), function);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.ContractRequest.function)
}

// string args = 4;
inline void ContractRequest::clear_args() {
  args_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractRequest::args() const {
  // @@protoc_insertion_point(field_get:rpcpb.ContractRequest.args)
  return args_.GetNoArena();
}
inline void ContractRequest::set_args(const ::std::string& value) {
  
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.ContractRequest.args)
}
#if LANG_CXX11
inline void ContractRequest::set_args(::std::string&& value) {
  
  args_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.ContractRequest.args)
}
#endif
inline void ContractRequest::set_args(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.ContractRequest.args)
}
inline void ContractRequest::set_args(const char* value, size_t size) {
  
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.ContractRequest.args)
}
inline ::std::string* ContractRequest::mutable_args() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.ContractRequest.args)
  return args_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractRequest::release_args() {
  // @@protoc_insertion_point(field_release:rpcpb.ContractRequest.args)
  
  return args_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractRequest::set_allocated_args(::std::string* args) {
  if (args != NULL) {
    
  } else {
    
  }
  args_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), args);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.ContractRequest.args)
}

// -------------------------------------------------------------------

// SendRawTransactionRequest

// bytes data = 1;
inline void SendRawTransactionRequest::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendRawTransactionRequest::data() const {
  // @@protoc_insertion_point(field_get:rpcpb.SendRawTransactionRequest.data)
  return data_.GetNoArena();
}
inline void SendRawTransactionRequest::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SendRawTransactionRequest.data)
}
#if LANG_CXX11
inline void SendRawTransactionRequest::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SendRawTransactionRequest.data)
}
#endif
inline void SendRawTransactionRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SendRawTransactionRequest.data)
}
inline void SendRawTransactionRequest::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SendRawTransactionRequest.data)
}
inline ::std::string* SendRawTransactionRequest::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SendRawTransactionRequest.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendRawTransactionRequest::release_data() {
  // @@protoc_insertion_point(field_release:rpcpb.SendRawTransactionRequest.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendRawTransactionRequest::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SendRawTransactionRequest.data)
}

// -------------------------------------------------------------------

// SendTransactionResponse

// string txhash = 1;
inline void SendTransactionResponse::clear_txhash() {
  txhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendTransactionResponse::txhash() const {
  // @@protoc_insertion_point(field_get:rpcpb.SendTransactionResponse.txhash)
  return txhash_.GetNoArena();
}
inline void SendTransactionResponse::set_txhash(const ::std::string& value) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SendTransactionResponse.txhash)
}
#if LANG_CXX11
inline void SendTransactionResponse::set_txhash(::std::string&& value) {
  
  txhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SendTransactionResponse.txhash)
}
#endif
inline void SendTransactionResponse::set_txhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SendTransactionResponse.txhash)
}
inline void SendTransactionResponse::set_txhash(const char* value, size_t size) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SendTransactionResponse.txhash)
}
inline ::std::string* SendTransactionResponse::mutable_txhash() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SendTransactionResponse.txhash)
  return txhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendTransactionResponse::release_txhash() {
  // @@protoc_insertion_point(field_release:rpcpb.SendTransactionResponse.txhash)
  
  return txhash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendTransactionResponse::set_allocated_txhash(::std::string* txhash) {
  if (txhash != NULL) {
    
  } else {
    
  }
  txhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txhash);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SendTransactionResponse.txhash)
}

// string contract_address = 2;
inline void SendTransactionResponse::clear_contract_address() {
  contract_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendTransactionResponse::contract_address() const {
  // @@protoc_insertion_point(field_get:rpcpb.SendTransactionResponse.contract_address)
  return contract_address_.GetNoArena();
}
inline void SendTransactionResponse::set_contract_address(const ::std::string& value) {
  
  contract_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SendTransactionResponse.contract_address)
}
#if LANG_CXX11
inline void SendTransactionResponse::set_contract_address(::std::string&& value) {
  
  contract_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SendTransactionResponse.contract_address)
}
#endif
inline void SendTransactionResponse::set_contract_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contract_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SendTransactionResponse.contract_address)
}
inline void SendTransactionResponse::set_contract_address(const char* value, size_t size) {
  
  contract_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SendTransactionResponse.contract_address)
}
inline ::std::string* SendTransactionResponse::mutable_contract_address() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SendTransactionResponse.contract_address)
  return contract_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendTransactionResponse::release_contract_address() {
  // @@protoc_insertion_point(field_release:rpcpb.SendTransactionResponse.contract_address)
  
  return contract_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendTransactionResponse::set_allocated_contract_address(::std::string* contract_address) {
  if (contract_address != NULL) {
    
  } else {
    
  }
  contract_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract_address);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SendTransactionResponse.contract_address)
}

// -------------------------------------------------------------------

// GetBlockByHashRequest

// string hash = 1;
inline void GetBlockByHashRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBlockByHashRequest::hash() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetBlockByHashRequest.hash)
  return hash_.GetNoArena();
}
inline void GetBlockByHashRequest::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GetBlockByHashRequest.hash)
}
#if LANG_CXX11
inline void GetBlockByHashRequest::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GetBlockByHashRequest.hash)
}
#endif
inline void GetBlockByHashRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GetBlockByHashRequest.hash)
}
inline void GetBlockByHashRequest::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetBlockByHashRequest.hash)
}
inline ::std::string* GetBlockByHashRequest::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GetBlockByHashRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBlockByHashRequest::release_hash() {
  // @@protoc_insertion_point(field_release:rpcpb.GetBlockByHashRequest.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBlockByHashRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetBlockByHashRequest.hash)
}

// bool full_fill_transaction = 2;
inline void GetBlockByHashRequest::clear_full_fill_transaction() {
  full_fill_transaction_ = false;
}
inline bool GetBlockByHashRequest::full_fill_transaction() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetBlockByHashRequest.full_fill_transaction)
  return full_fill_transaction_;
}
inline void GetBlockByHashRequest::set_full_fill_transaction(bool value) {
  
  full_fill_transaction_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.GetBlockByHashRequest.full_fill_transaction)
}

// -------------------------------------------------------------------

// GetBlockByHeightRequest

// uint64 height = 1;
inline void GetBlockByHeightRequest::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetBlockByHeightRequest::height() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetBlockByHeightRequest.height)
  return height_;
}
inline void GetBlockByHeightRequest::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.GetBlockByHeightRequest.height)
}

// bool full_fill_transaction = 2;
inline void GetBlockByHeightRequest::clear_full_fill_transaction() {
  full_fill_transaction_ = false;
}
inline bool GetBlockByHeightRequest::full_fill_transaction() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetBlockByHeightRequest.full_fill_transaction)
  return full_fill_transaction_;
}
inline void GetBlockByHeightRequest::set_full_fill_transaction(bool value) {
  
  full_fill_transaction_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.GetBlockByHeightRequest.full_fill_transaction)
}

// -------------------------------------------------------------------

// GetTransactionByHashRequest

// string hash = 1;
inline void GetTransactionByHashRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetTransactionByHashRequest::hash() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetTransactionByHashRequest.hash)
  return hash_.GetNoArena();
}
inline void GetTransactionByHashRequest::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GetTransactionByHashRequest.hash)
}
#if LANG_CXX11
inline void GetTransactionByHashRequest::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GetTransactionByHashRequest.hash)
}
#endif
inline void GetTransactionByHashRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GetTransactionByHashRequest.hash)
}
inline void GetTransactionByHashRequest::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetTransactionByHashRequest.hash)
}
inline ::std::string* GetTransactionByHashRequest::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GetTransactionByHashRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTransactionByHashRequest::release_hash() {
  // @@protoc_insertion_point(field_release:rpcpb.GetTransactionByHashRequest.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTransactionByHashRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetTransactionByHashRequest.hash)
}

// -------------------------------------------------------------------

// GetTransactionByContractRequest

// string address = 1;
inline void GetTransactionByContractRequest::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetTransactionByContractRequest::address() const {
  // @@protoc_insertion_point(field_get:rpcpb.GetTransactionByContractRequest.address)
  return address_.GetNoArena();
}
inline void GetTransactionByContractRequest::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GetTransactionByContractRequest.address)
}
#if LANG_CXX11
inline void GetTransactionByContractRequest::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GetTransactionByContractRequest.address)
}
#endif
inline void GetTransactionByContractRequest::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GetTransactionByContractRequest.address)
}
inline void GetTransactionByContractRequest::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GetTransactionByContractRequest.address)
}
inline ::std::string* GetTransactionByContractRequest::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GetTransactionByContractRequest.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTransactionByContractRequest::release_address() {
  // @@protoc_insertion_point(field_release:rpcpb.GetTransactionByContractRequest.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTransactionByContractRequest::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetTransactionByContractRequest.address)
}

// -------------------------------------------------------------------

// BlockResponse

// string hash = 1;
inline void BlockResponse::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockResponse::hash() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.hash)
  return hash_.GetNoArena();
}
inline void BlockResponse::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.hash)
}
#if LANG_CXX11
inline void BlockResponse::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.BlockResponse.hash)
}
#endif
inline void BlockResponse::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.BlockResponse.hash)
}
inline void BlockResponse::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.BlockResponse.hash)
}
inline ::std::string* BlockResponse::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockResponse::release_hash() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockResponse::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.hash)
}

// string parent_hash = 2;
inline void BlockResponse::clear_parent_hash() {
  parent_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockResponse::parent_hash() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.parent_hash)
  return parent_hash_.GetNoArena();
}
inline void BlockResponse::set_parent_hash(const ::std::string& value) {
  
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.parent_hash)
}
#if LANG_CXX11
inline void BlockResponse::set_parent_hash(::std::string&& value) {
  
  parent_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.BlockResponse.parent_hash)
}
#endif
inline void BlockResponse::set_parent_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.BlockResponse.parent_hash)
}
inline void BlockResponse::set_parent_hash(const char* value, size_t size) {
  
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.BlockResponse.parent_hash)
}
inline ::std::string* BlockResponse::mutable_parent_hash() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.parent_hash)
  return parent_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockResponse::release_parent_hash() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.parent_hash)
  
  return parent_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockResponse::set_allocated_parent_hash(::std::string* parent_hash) {
  if (parent_hash != NULL) {
    
  } else {
    
  }
  parent_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_hash);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.parent_hash)
}

// uint64 height = 3;
inline void BlockResponse::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockResponse::height() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.height)
  return height_;
}
inline void BlockResponse::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.height)
}

// uint64 nonce = 4;
inline void BlockResponse::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockResponse::nonce() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.nonce)
  return nonce_;
}
inline void BlockResponse::set_nonce(::google::protobuf::uint64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.nonce)
}

// string coinbase = 5;
inline void BlockResponse::clear_coinbase() {
  coinbase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockResponse::coinbase() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.coinbase)
  return coinbase_.GetNoArena();
}
inline void BlockResponse::set_coinbase(const ::std::string& value) {
  
  coinbase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.coinbase)
}
#if LANG_CXX11
inline void BlockResponse::set_coinbase(::std::string&& value) {
  
  coinbase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.BlockResponse.coinbase)
}
#endif
inline void BlockResponse::set_coinbase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  coinbase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.BlockResponse.coinbase)
}
inline void BlockResponse::set_coinbase(const char* value, size_t size) {
  
  coinbase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.BlockResponse.coinbase)
}
inline ::std::string* BlockResponse::mutable_coinbase() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.coinbase)
  return coinbase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockResponse::release_coinbase() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.coinbase)
  
  return coinbase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockResponse::set_allocated_coinbase(::std::string* coinbase) {
  if (coinbase != NULL) {
    
  } else {
    
  }
  coinbase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coinbase);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.coinbase)
}

// int64 timestamp = 6;
inline void BlockResponse::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.timestamp)
  return timestamp_;
}
inline void BlockResponse::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.timestamp)
}

// uint32 chain_id = 7;
inline void BlockResponse::clear_chain_id() {
  chain_id_ = 0u;
}
inline ::google::protobuf::uint32 BlockResponse::chain_id() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.chain_id)
  return chain_id_;
}
inline void BlockResponse::set_chain_id(::google::protobuf::uint32 value) {
  
  chain_id_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.chain_id)
}

// string state_root = 8;
inline void BlockResponse::clear_state_root() {
  state_root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockResponse::state_root() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.state_root)
  return state_root_.GetNoArena();
}
inline void BlockResponse::set_state_root(const ::std::string& value) {
  
  state_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.state_root)
}
#if LANG_CXX11
inline void BlockResponse::set_state_root(::std::string&& value) {
  
  state_root_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.BlockResponse.state_root)
}
#endif
inline void BlockResponse::set_state_root(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  state_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.BlockResponse.state_root)
}
inline void BlockResponse::set_state_root(const char* value, size_t size) {
  
  state_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.BlockResponse.state_root)
}
inline ::std::string* BlockResponse::mutable_state_root() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.state_root)
  return state_root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockResponse::release_state_root() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.state_root)
  
  return state_root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockResponse::set_allocated_state_root(::std::string* state_root) {
  if (state_root != NULL) {
    
  } else {
    
  }
  state_root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state_root);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.state_root)
}

// string txs_root = 9;
inline void BlockResponse::clear_txs_root() {
  txs_root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockResponse::txs_root() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.txs_root)
  return txs_root_.GetNoArena();
}
inline void BlockResponse::set_txs_root(const ::std::string& value) {
  
  txs_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.txs_root)
}
#if LANG_CXX11
inline void BlockResponse::set_txs_root(::std::string&& value) {
  
  txs_root_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.BlockResponse.txs_root)
}
#endif
inline void BlockResponse::set_txs_root(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txs_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.BlockResponse.txs_root)
}
inline void BlockResponse::set_txs_root(const char* value, size_t size) {
  
  txs_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.BlockResponse.txs_root)
}
inline ::std::string* BlockResponse::mutable_txs_root() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.txs_root)
  return txs_root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockResponse::release_txs_root() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.txs_root)
  
  return txs_root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockResponse::set_allocated_txs_root(::std::string* txs_root) {
  if (txs_root != NULL) {
    
  } else {
    
  }
  txs_root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txs_root);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.txs_root)
}

// string events_root = 10;
inline void BlockResponse::clear_events_root() {
  events_root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockResponse::events_root() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.events_root)
  return events_root_.GetNoArena();
}
inline void BlockResponse::set_events_root(const ::std::string& value) {
  
  events_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.events_root)
}
#if LANG_CXX11
inline void BlockResponse::set_events_root(::std::string&& value) {
  
  events_root_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.BlockResponse.events_root)
}
#endif
inline void BlockResponse::set_events_root(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  events_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.BlockResponse.events_root)
}
inline void BlockResponse::set_events_root(const char* value, size_t size) {
  
  events_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.BlockResponse.events_root)
}
inline ::std::string* BlockResponse::mutable_events_root() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.events_root)
  return events_root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockResponse::release_events_root() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.events_root)
  
  return events_root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockResponse::set_allocated_events_root(::std::string* events_root) {
  if (events_root != NULL) {
    
  } else {
    
  }
  events_root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), events_root);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.events_root)
}

// .consensuspb.ConsensusRoot consensus_root = 11;
inline bool BlockResponse::has_consensus_root() const {
  return this != internal_default_instance() && consensus_root_ != NULL;
}
inline const ::consensuspb::ConsensusRoot& BlockResponse::consensus_root() const {
  const ::consensuspb::ConsensusRoot* p = consensus_root_;
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.consensus_root)
  return p != NULL ? *p : *reinterpret_cast<const ::consensuspb::ConsensusRoot*>(
      &::consensuspb::_ConsensusRoot_default_instance_);
}
inline ::consensuspb::ConsensusRoot* BlockResponse::release_consensus_root() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.consensus_root)
  
  ::consensuspb::ConsensusRoot* temp = consensus_root_;
  consensus_root_ = NULL;
  return temp;
}
inline ::consensuspb::ConsensusRoot* BlockResponse::mutable_consensus_root() {
  
  if (consensus_root_ == NULL) {
    consensus_root_ = new ::consensuspb::ConsensusRoot;
  }
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.consensus_root)
  return consensus_root_;
}
inline void BlockResponse::set_allocated_consensus_root(::consensuspb::ConsensusRoot* consensus_root) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(consensus_root_);
  }
  if (consensus_root) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      consensus_root = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, consensus_root, submessage_arena);
    }
    
  } else {
    
  }
  consensus_root_ = consensus_root;
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.consensus_root)
}

// string miner = 12;
inline void BlockResponse::clear_miner() {
  miner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockResponse::miner() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.miner)
  return miner_.GetNoArena();
}
inline void BlockResponse::set_miner(const ::std::string& value) {
  
  miner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.miner)
}
#if LANG_CXX11
inline void BlockResponse::set_miner(::std::string&& value) {
  
  miner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.BlockResponse.miner)
}
#endif
inline void BlockResponse::set_miner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  miner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.BlockResponse.miner)
}
inline void BlockResponse::set_miner(const char* value, size_t size) {
  
  miner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.BlockResponse.miner)
}
inline ::std::string* BlockResponse::mutable_miner() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.miner)
  return miner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockResponse::release_miner() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.miner)
  
  return miner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockResponse::set_allocated_miner(::std::string* miner) {
  if (miner != NULL) {
    
  } else {
    
  }
  miner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), miner);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.miner)
}

// string randomSeed = 13;
inline void BlockResponse::clear_randomseed() {
  randomseed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockResponse::randomseed() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.randomSeed)
  return randomseed_.GetNoArena();
}
inline void BlockResponse::set_randomseed(const ::std::string& value) {
  
  randomseed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.randomSeed)
}
#if LANG_CXX11
inline void BlockResponse::set_randomseed(::std::string&& value) {
  
  randomseed_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.BlockResponse.randomSeed)
}
#endif
inline void BlockResponse::set_randomseed(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  randomseed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.BlockResponse.randomSeed)
}
inline void BlockResponse::set_randomseed(const char* value, size_t size) {
  
  randomseed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.BlockResponse.randomSeed)
}
inline ::std::string* BlockResponse::mutable_randomseed() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.randomSeed)
  return randomseed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockResponse::release_randomseed() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.randomSeed)
  
  return randomseed_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockResponse::set_allocated_randomseed(::std::string* randomseed) {
  if (randomseed != NULL) {
    
  } else {
    
  }
  randomseed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), randomseed);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.randomSeed)
}

// string randomProof = 14;
inline void BlockResponse::clear_randomproof() {
  randomproof_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockResponse::randomproof() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.randomProof)
  return randomproof_.GetNoArena();
}
inline void BlockResponse::set_randomproof(const ::std::string& value) {
  
  randomproof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.randomProof)
}
#if LANG_CXX11
inline void BlockResponse::set_randomproof(::std::string&& value) {
  
  randomproof_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.BlockResponse.randomProof)
}
#endif
inline void BlockResponse::set_randomproof(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  randomproof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.BlockResponse.randomProof)
}
inline void BlockResponse::set_randomproof(const char* value, size_t size) {
  
  randomproof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.BlockResponse.randomProof)
}
inline ::std::string* BlockResponse::mutable_randomproof() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.randomProof)
  return randomproof_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockResponse::release_randomproof() {
  // @@protoc_insertion_point(field_release:rpcpb.BlockResponse.randomProof)
  
  return randomproof_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockResponse::set_allocated_randomproof(::std::string* randomproof) {
  if (randomproof != NULL) {
    
  } else {
    
  }
  randomproof_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), randomproof);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.BlockResponse.randomProof)
}

// bool is_finality = 15;
inline void BlockResponse::clear_is_finality() {
  is_finality_ = false;
}
inline bool BlockResponse::is_finality() const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.is_finality)
  return is_finality_;
}
inline void BlockResponse::set_is_finality(bool value) {
  
  is_finality_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.BlockResponse.is_finality)
}

// repeated .rpcpb.TransactionResponse transactions = 100;
inline int BlockResponse::transactions_size() const {
  return transactions_.size();
}
inline void BlockResponse::clear_transactions() {
  transactions_.Clear();
}
inline const ::rpcpb::TransactionResponse& BlockResponse::transactions(int index) const {
  // @@protoc_insertion_point(field_get:rpcpb.BlockResponse.transactions)
  return transactions_.Get(index);
}
inline ::rpcpb::TransactionResponse* BlockResponse::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:rpcpb.BlockResponse.transactions)
  return transactions_.Mutable(index);
}
inline ::rpcpb::TransactionResponse* BlockResponse::add_transactions() {
  // @@protoc_insertion_point(field_add:rpcpb.BlockResponse.transactions)
  return transactions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::rpcpb::TransactionResponse >*
BlockResponse::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:rpcpb.BlockResponse.transactions)
  return &transactions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::rpcpb::TransactionResponse >&
BlockResponse::transactions() const {
  // @@protoc_insertion_point(field_list:rpcpb.BlockResponse.transactions)
  return transactions_;
}

// -------------------------------------------------------------------

// TransactionResponse

// string hash = 1;
inline void TransactionResponse::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::hash() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.hash)
  return hash_.GetNoArena();
}
inline void TransactionResponse::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.hash)
}
#if LANG_CXX11
inline void TransactionResponse::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.hash)
}
#endif
inline void TransactionResponse::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.hash)
}
inline void TransactionResponse::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.hash)
}
inline ::std::string* TransactionResponse::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_hash() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.hash)
}

// uint32 chainId = 2;
inline void TransactionResponse::clear_chainid() {
  chainid_ = 0u;
}
inline ::google::protobuf::uint32 TransactionResponse::chainid() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.chainId)
  return chainid_;
}
inline void TransactionResponse::set_chainid(::google::protobuf::uint32 value) {
  
  chainid_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.chainId)
}

// string from = 3;
inline void TransactionResponse::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::from() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.from)
  return from_.GetNoArena();
}
inline void TransactionResponse::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.from)
}
#if LANG_CXX11
inline void TransactionResponse::set_from(::std::string&& value) {
  
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.from)
}
#endif
inline void TransactionResponse::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.from)
}
inline void TransactionResponse::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.from)
}
inline ::std::string* TransactionResponse::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_from() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.from)
}

// string to = 4;
inline void TransactionResponse::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::to() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.to)
  return to_.GetNoArena();
}
inline void TransactionResponse::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.to)
}
#if LANG_CXX11
inline void TransactionResponse::set_to(::std::string&& value) {
  
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.to)
}
#endif
inline void TransactionResponse::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.to)
}
inline void TransactionResponse::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.to)
}
inline ::std::string* TransactionResponse::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_to() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.to)
}

// string value = 5;
inline void TransactionResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::value() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.value)
  return value_.GetNoArena();
}
inline void TransactionResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.value)
}
#if LANG_CXX11
inline void TransactionResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.value)
}
#endif
inline void TransactionResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.value)
}
inline void TransactionResponse::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.value)
}
inline ::std::string* TransactionResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_value() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.value)
}

// uint64 nonce = 6;
inline void TransactionResponse::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TransactionResponse::nonce() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.nonce)
  return nonce_;
}
inline void TransactionResponse::set_nonce(::google::protobuf::uint64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.nonce)
}

// int64 timestamp = 7;
inline void TransactionResponse::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TransactionResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.timestamp)
  return timestamp_;
}
inline void TransactionResponse::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.timestamp)
}

// string type = 8;
inline void TransactionResponse::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::type() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.type)
  return type_.GetNoArena();
}
inline void TransactionResponse::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.type)
}
#if LANG_CXX11
inline void TransactionResponse::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.type)
}
#endif
inline void TransactionResponse::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.type)
}
inline void TransactionResponse::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.type)
}
inline ::std::string* TransactionResponse::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_type() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.type)
}

// bytes data = 9;
inline void TransactionResponse::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::data() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.data)
  return data_.GetNoArena();
}
inline void TransactionResponse::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.data)
}
#if LANG_CXX11
inline void TransactionResponse::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.data)
}
#endif
inline void TransactionResponse::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.data)
}
inline void TransactionResponse::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.data)
}
inline ::std::string* TransactionResponse::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_data() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.data)
}

// string gas_price = 10;
inline void TransactionResponse::clear_gas_price() {
  gas_price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::gas_price() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.gas_price)
  return gas_price_.GetNoArena();
}
inline void TransactionResponse::set_gas_price(const ::std::string& value) {
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.gas_price)
}
#if LANG_CXX11
inline void TransactionResponse::set_gas_price(::std::string&& value) {
  
  gas_price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.gas_price)
}
#endif
inline void TransactionResponse::set_gas_price(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.gas_price)
}
inline void TransactionResponse::set_gas_price(const char* value, size_t size) {
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.gas_price)
}
inline ::std::string* TransactionResponse::mutable_gas_price() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.gas_price)
  return gas_price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_gas_price() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.gas_price)
  
  return gas_price_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_gas_price(::std::string* gas_price) {
  if (gas_price != NULL) {
    
  } else {
    
  }
  gas_price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_price);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.gas_price)
}

// string gas_limit = 11;
inline void TransactionResponse::clear_gas_limit() {
  gas_limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::gas_limit() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.gas_limit)
  return gas_limit_.GetNoArena();
}
inline void TransactionResponse::set_gas_limit(const ::std::string& value) {
  
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.gas_limit)
}
#if LANG_CXX11
inline void TransactionResponse::set_gas_limit(::std::string&& value) {
  
  gas_limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.gas_limit)
}
#endif
inline void TransactionResponse::set_gas_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.gas_limit)
}
inline void TransactionResponse::set_gas_limit(const char* value, size_t size) {
  
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.gas_limit)
}
inline ::std::string* TransactionResponse::mutable_gas_limit() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.gas_limit)
  return gas_limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_gas_limit() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.gas_limit)
  
  return gas_limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_gas_limit(::std::string* gas_limit) {
  if (gas_limit != NULL) {
    
  } else {
    
  }
  gas_limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_limit);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.gas_limit)
}

// string contract_address = 12;
inline void TransactionResponse::clear_contract_address() {
  contract_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::contract_address() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.contract_address)
  return contract_address_.GetNoArena();
}
inline void TransactionResponse::set_contract_address(const ::std::string& value) {
  
  contract_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.contract_address)
}
#if LANG_CXX11
inline void TransactionResponse::set_contract_address(::std::string&& value) {
  
  contract_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.contract_address)
}
#endif
inline void TransactionResponse::set_contract_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contract_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.contract_address)
}
inline void TransactionResponse::set_contract_address(const char* value, size_t size) {
  
  contract_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.contract_address)
}
inline ::std::string* TransactionResponse::mutable_contract_address() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.contract_address)
  return contract_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_contract_address() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.contract_address)
  
  return contract_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_contract_address(::std::string* contract_address) {
  if (contract_address != NULL) {
    
  } else {
    
  }
  contract_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract_address);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.contract_address)
}

// int32 status = 13;
inline void TransactionResponse::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 TransactionResponse::status() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.status)
  return status_;
}
inline void TransactionResponse::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.status)
}

// string gas_used = 14;
inline void TransactionResponse::clear_gas_used() {
  gas_used_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::gas_used() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.gas_used)
  return gas_used_.GetNoArena();
}
inline void TransactionResponse::set_gas_used(const ::std::string& value) {
  
  gas_used_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.gas_used)
}
#if LANG_CXX11
inline void TransactionResponse::set_gas_used(::std::string&& value) {
  
  gas_used_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.gas_used)
}
#endif
inline void TransactionResponse::set_gas_used(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gas_used_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.gas_used)
}
inline void TransactionResponse::set_gas_used(const char* value, size_t size) {
  
  gas_used_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.gas_used)
}
inline ::std::string* TransactionResponse::mutable_gas_used() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.gas_used)
  return gas_used_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_gas_used() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.gas_used)
  
  return gas_used_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_gas_used(::std::string* gas_used) {
  if (gas_used != NULL) {
    
  } else {
    
  }
  gas_used_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_used);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.gas_used)
}

// string execute_error = 15;
inline void TransactionResponse::clear_execute_error() {
  execute_error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::execute_error() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.execute_error)
  return execute_error_.GetNoArena();
}
inline void TransactionResponse::set_execute_error(const ::std::string& value) {
  
  execute_error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.execute_error)
}
#if LANG_CXX11
inline void TransactionResponse::set_execute_error(::std::string&& value) {
  
  execute_error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.execute_error)
}
#endif
inline void TransactionResponse::set_execute_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  execute_error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.execute_error)
}
inline void TransactionResponse::set_execute_error(const char* value, size_t size) {
  
  execute_error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.execute_error)
}
inline ::std::string* TransactionResponse::mutable_execute_error() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.execute_error)
  return execute_error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_execute_error() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.execute_error)
  
  return execute_error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_execute_error(::std::string* execute_error) {
  if (execute_error != NULL) {
    
  } else {
    
  }
  execute_error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), execute_error);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.execute_error)
}

// string execute_result = 16;
inline void TransactionResponse::clear_execute_result() {
  execute_result_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransactionResponse::execute_result() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.execute_result)
  return execute_result_.GetNoArena();
}
inline void TransactionResponse::set_execute_result(const ::std::string& value) {
  
  execute_result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.execute_result)
}
#if LANG_CXX11
inline void TransactionResponse::set_execute_result(::std::string&& value) {
  
  execute_result_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.TransactionResponse.execute_result)
}
#endif
inline void TransactionResponse::set_execute_result(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  execute_result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.TransactionResponse.execute_result)
}
inline void TransactionResponse::set_execute_result(const char* value, size_t size) {
  
  execute_result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.TransactionResponse.execute_result)
}
inline ::std::string* TransactionResponse::mutable_execute_result() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.TransactionResponse.execute_result)
  return execute_result_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionResponse::release_execute_result() {
  // @@protoc_insertion_point(field_release:rpcpb.TransactionResponse.execute_result)
  
  return execute_result_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionResponse::set_allocated_execute_result(::std::string* execute_result) {
  if (execute_result != NULL) {
    
  } else {
    
  }
  execute_result_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), execute_result);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.TransactionResponse.execute_result)
}

// uint64 block_height = 17;
inline void TransactionResponse::clear_block_height() {
  block_height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TransactionResponse::block_height() const {
  // @@protoc_insertion_point(field_get:rpcpb.TransactionResponse.block_height)
  return block_height_;
}
inline void TransactionResponse::set_block_height(::google::protobuf::uint64 value) {
  
  block_height_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.TransactionResponse.block_height)
}

// -------------------------------------------------------------------

// NewAccountRequest

// string passphrase = 1;
inline void NewAccountRequest::clear_passphrase() {
  passphrase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewAccountRequest::passphrase() const {
  // @@protoc_insertion_point(field_get:rpcpb.NewAccountRequest.passphrase)
  return passphrase_.GetNoArena();
}
inline void NewAccountRequest::set_passphrase(const ::std::string& value) {
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NewAccountRequest.passphrase)
}
#if LANG_CXX11
inline void NewAccountRequest::set_passphrase(::std::string&& value) {
  
  passphrase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NewAccountRequest.passphrase)
}
#endif
inline void NewAccountRequest::set_passphrase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NewAccountRequest.passphrase)
}
inline void NewAccountRequest::set_passphrase(const char* value, size_t size) {
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NewAccountRequest.passphrase)
}
inline ::std::string* NewAccountRequest::mutable_passphrase() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NewAccountRequest.passphrase)
  return passphrase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAccountRequest::release_passphrase() {
  // @@protoc_insertion_point(field_release:rpcpb.NewAccountRequest.passphrase)
  
  return passphrase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAccountRequest::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase != NULL) {
    
  } else {
    
  }
  passphrase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passphrase);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NewAccountRequest.passphrase)
}

// -------------------------------------------------------------------

// NewAccountResponse

// string address = 1;
inline void NewAccountResponse::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewAccountResponse::address() const {
  // @@protoc_insertion_point(field_get:rpcpb.NewAccountResponse.address)
  return address_.GetNoArena();
}
inline void NewAccountResponse::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NewAccountResponse.address)
}
#if LANG_CXX11
inline void NewAccountResponse::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NewAccountResponse.address)
}
#endif
inline void NewAccountResponse::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NewAccountResponse.address)
}
inline void NewAccountResponse::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NewAccountResponse.address)
}
inline ::std::string* NewAccountResponse::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NewAccountResponse.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAccountResponse::release_address() {
  // @@protoc_insertion_point(field_release:rpcpb.NewAccountResponse.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAccountResponse::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NewAccountResponse.address)
}

// -------------------------------------------------------------------

// UnlockAccountRequest

// string address = 1;
inline void UnlockAccountRequest::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockAccountRequest::address() const {
  // @@protoc_insertion_point(field_get:rpcpb.UnlockAccountRequest.address)
  return address_.GetNoArena();
}
inline void UnlockAccountRequest::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.UnlockAccountRequest.address)
}
#if LANG_CXX11
inline void UnlockAccountRequest::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.UnlockAccountRequest.address)
}
#endif
inline void UnlockAccountRequest::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.UnlockAccountRequest.address)
}
inline void UnlockAccountRequest::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.UnlockAccountRequest.address)
}
inline ::std::string* UnlockAccountRequest::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.UnlockAccountRequest.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockAccountRequest::release_address() {
  // @@protoc_insertion_point(field_release:rpcpb.UnlockAccountRequest.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockAccountRequest::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.UnlockAccountRequest.address)
}

// string passphrase = 2;
inline void UnlockAccountRequest::clear_passphrase() {
  passphrase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnlockAccountRequest::passphrase() const {
  // @@protoc_insertion_point(field_get:rpcpb.UnlockAccountRequest.passphrase)
  return passphrase_.GetNoArena();
}
inline void UnlockAccountRequest::set_passphrase(const ::std::string& value) {
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.UnlockAccountRequest.passphrase)
}
#if LANG_CXX11
inline void UnlockAccountRequest::set_passphrase(::std::string&& value) {
  
  passphrase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.UnlockAccountRequest.passphrase)
}
#endif
inline void UnlockAccountRequest::set_passphrase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.UnlockAccountRequest.passphrase)
}
inline void UnlockAccountRequest::set_passphrase(const char* value, size_t size) {
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.UnlockAccountRequest.passphrase)
}
inline ::std::string* UnlockAccountRequest::mutable_passphrase() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.UnlockAccountRequest.passphrase)
  return passphrase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnlockAccountRequest::release_passphrase() {
  // @@protoc_insertion_point(field_release:rpcpb.UnlockAccountRequest.passphrase)
  
  return passphrase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnlockAccountRequest::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase != NULL) {
    
  } else {
    
  }
  passphrase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passphrase);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.UnlockAccountRequest.passphrase)
}

// uint64 duration = 3;
inline void UnlockAccountRequest::clear_duration() {
  duration_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UnlockAccountRequest::duration() const {
  // @@protoc_insertion_point(field_get:rpcpb.UnlockAccountRequest.duration)
  return duration_;
}
inline void UnlockAccountRequest::set_duration(::google::protobuf::uint64 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.UnlockAccountRequest.duration)
}

// -------------------------------------------------------------------

// UnlockAccountResponse

// bool result = 1;
inline void UnlockAccountResponse::clear_result() {
  result_ = false;
}
inline bool UnlockAccountResponse::result() const {
  // @@protoc_insertion_point(field_get:rpcpb.UnlockAccountResponse.result)
  return result_;
}
inline void UnlockAccountResponse::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.UnlockAccountResponse.result)
}

// -------------------------------------------------------------------

// LockAccountRequest

// string address = 1;
inline void LockAccountRequest::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockAccountRequest::address() const {
  // @@protoc_insertion_point(field_get:rpcpb.LockAccountRequest.address)
  return address_.GetNoArena();
}
inline void LockAccountRequest::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.LockAccountRequest.address)
}
#if LANG_CXX11
inline void LockAccountRequest::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.LockAccountRequest.address)
}
#endif
inline void LockAccountRequest::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.LockAccountRequest.address)
}
inline void LockAccountRequest::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.LockAccountRequest.address)
}
inline ::std::string* LockAccountRequest::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.LockAccountRequest.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockAccountRequest::release_address() {
  // @@protoc_insertion_point(field_release:rpcpb.LockAccountRequest.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockAccountRequest::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.LockAccountRequest.address)
}

// -------------------------------------------------------------------

// LockAccountResponse

// bool result = 1;
inline void LockAccountResponse::clear_result() {
  result_ = false;
}
inline bool LockAccountResponse::result() const {
  // @@protoc_insertion_point(field_get:rpcpb.LockAccountResponse.result)
  return result_;
}
inline void LockAccountResponse::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.LockAccountResponse.result)
}

// -------------------------------------------------------------------

// SignHashRequest

// string address = 1;
inline void SignHashRequest::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignHashRequest::address() const {
  // @@protoc_insertion_point(field_get:rpcpb.SignHashRequest.address)
  return address_.GetNoArena();
}
inline void SignHashRequest::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SignHashRequest.address)
}
#if LANG_CXX11
inline void SignHashRequest::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SignHashRequest.address)
}
#endif
inline void SignHashRequest::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SignHashRequest.address)
}
inline void SignHashRequest::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SignHashRequest.address)
}
inline ::std::string* SignHashRequest::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SignHashRequest.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignHashRequest::release_address() {
  // @@protoc_insertion_point(field_release:rpcpb.SignHashRequest.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignHashRequest::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SignHashRequest.address)
}

// bytes hash = 2;
inline void SignHashRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignHashRequest::hash() const {
  // @@protoc_insertion_point(field_get:rpcpb.SignHashRequest.hash)
  return hash_.GetNoArena();
}
inline void SignHashRequest::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SignHashRequest.hash)
}
#if LANG_CXX11
inline void SignHashRequest::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SignHashRequest.hash)
}
#endif
inline void SignHashRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SignHashRequest.hash)
}
inline void SignHashRequest::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SignHashRequest.hash)
}
inline ::std::string* SignHashRequest::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SignHashRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignHashRequest::release_hash() {
  // @@protoc_insertion_point(field_release:rpcpb.SignHashRequest.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignHashRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SignHashRequest.hash)
}

// uint32 alg = 3;
inline void SignHashRequest::clear_alg() {
  alg_ = 0u;
}
inline ::google::protobuf::uint32 SignHashRequest::alg() const {
  // @@protoc_insertion_point(field_get:rpcpb.SignHashRequest.alg)
  return alg_;
}
inline void SignHashRequest::set_alg(::google::protobuf::uint32 value) {
  
  alg_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.SignHashRequest.alg)
}

// -------------------------------------------------------------------

// SignHashResponse

// bytes data = 1;
inline void SignHashResponse::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignHashResponse::data() const {
  // @@protoc_insertion_point(field_get:rpcpb.SignHashResponse.data)
  return data_.GetNoArena();
}
inline void SignHashResponse::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SignHashResponse.data)
}
#if LANG_CXX11
inline void SignHashResponse::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SignHashResponse.data)
}
#endif
inline void SignHashResponse::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SignHashResponse.data)
}
inline void SignHashResponse::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SignHashResponse.data)
}
inline ::std::string* SignHashResponse::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SignHashResponse.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignHashResponse::release_data() {
  // @@protoc_insertion_point(field_release:rpcpb.SignHashResponse.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignHashResponse::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SignHashResponse.data)
}

// -------------------------------------------------------------------

// GenerateRandomSeedRequest

// string address = 1;
inline void GenerateRandomSeedRequest::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GenerateRandomSeedRequest::address() const {
  // @@protoc_insertion_point(field_get:rpcpb.GenerateRandomSeedRequest.address)
  return address_.GetNoArena();
}
inline void GenerateRandomSeedRequest::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GenerateRandomSeedRequest.address)
}
#if LANG_CXX11
inline void GenerateRandomSeedRequest::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GenerateRandomSeedRequest.address)
}
#endif
inline void GenerateRandomSeedRequest::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GenerateRandomSeedRequest.address)
}
inline void GenerateRandomSeedRequest::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GenerateRandomSeedRequest.address)
}
inline ::std::string* GenerateRandomSeedRequest::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GenerateRandomSeedRequest.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GenerateRandomSeedRequest::release_address() {
  // @@protoc_insertion_point(field_release:rpcpb.GenerateRandomSeedRequest.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenerateRandomSeedRequest::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GenerateRandomSeedRequest.address)
}

// bytes parent_seed = 2;
inline void GenerateRandomSeedRequest::clear_parent_seed() {
  parent_seed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GenerateRandomSeedRequest::parent_seed() const {
  // @@protoc_insertion_point(field_get:rpcpb.GenerateRandomSeedRequest.parent_seed)
  return parent_seed_.GetNoArena();
}
inline void GenerateRandomSeedRequest::set_parent_seed(const ::std::string& value) {
  
  parent_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GenerateRandomSeedRequest.parent_seed)
}
#if LANG_CXX11
inline void GenerateRandomSeedRequest::set_parent_seed(::std::string&& value) {
  
  parent_seed_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GenerateRandomSeedRequest.parent_seed)
}
#endif
inline void GenerateRandomSeedRequest::set_parent_seed(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GenerateRandomSeedRequest.parent_seed)
}
inline void GenerateRandomSeedRequest::set_parent_seed(const void* value, size_t size) {
  
  parent_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GenerateRandomSeedRequest.parent_seed)
}
inline ::std::string* GenerateRandomSeedRequest::mutable_parent_seed() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GenerateRandomSeedRequest.parent_seed)
  return parent_seed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GenerateRandomSeedRequest::release_parent_seed() {
  // @@protoc_insertion_point(field_release:rpcpb.GenerateRandomSeedRequest.parent_seed)
  
  return parent_seed_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenerateRandomSeedRequest::set_allocated_parent_seed(::std::string* parent_seed) {
  if (parent_seed != NULL) {
    
  } else {
    
  }
  parent_seed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_seed);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GenerateRandomSeedRequest.parent_seed)
}

// bytes ancestor_hash = 3;
inline void GenerateRandomSeedRequest::clear_ancestor_hash() {
  ancestor_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GenerateRandomSeedRequest::ancestor_hash() const {
  // @@protoc_insertion_point(field_get:rpcpb.GenerateRandomSeedRequest.ancestor_hash)
  return ancestor_hash_.GetNoArena();
}
inline void GenerateRandomSeedRequest::set_ancestor_hash(const ::std::string& value) {
  
  ancestor_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GenerateRandomSeedRequest.ancestor_hash)
}
#if LANG_CXX11
inline void GenerateRandomSeedRequest::set_ancestor_hash(::std::string&& value) {
  
  ancestor_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GenerateRandomSeedRequest.ancestor_hash)
}
#endif
inline void GenerateRandomSeedRequest::set_ancestor_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ancestor_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GenerateRandomSeedRequest.ancestor_hash)
}
inline void GenerateRandomSeedRequest::set_ancestor_hash(const void* value, size_t size) {
  
  ancestor_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GenerateRandomSeedRequest.ancestor_hash)
}
inline ::std::string* GenerateRandomSeedRequest::mutable_ancestor_hash() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GenerateRandomSeedRequest.ancestor_hash)
  return ancestor_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GenerateRandomSeedRequest::release_ancestor_hash() {
  // @@protoc_insertion_point(field_release:rpcpb.GenerateRandomSeedRequest.ancestor_hash)
  
  return ancestor_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenerateRandomSeedRequest::set_allocated_ancestor_hash(::std::string* ancestor_hash) {
  if (ancestor_hash != NULL) {
    
  } else {
    
  }
  ancestor_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ancestor_hash);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GenerateRandomSeedRequest.ancestor_hash)
}

// -------------------------------------------------------------------

// GenerateRandomSeedResponse

// bytes vrf_seed = 1;
inline void GenerateRandomSeedResponse::clear_vrf_seed() {
  vrf_seed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GenerateRandomSeedResponse::vrf_seed() const {
  // @@protoc_insertion_point(field_get:rpcpb.GenerateRandomSeedResponse.vrf_seed)
  return vrf_seed_.GetNoArena();
}
inline void GenerateRandomSeedResponse::set_vrf_seed(const ::std::string& value) {
  
  vrf_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GenerateRandomSeedResponse.vrf_seed)
}
#if LANG_CXX11
inline void GenerateRandomSeedResponse::set_vrf_seed(::std::string&& value) {
  
  vrf_seed_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GenerateRandomSeedResponse.vrf_seed)
}
#endif
inline void GenerateRandomSeedResponse::set_vrf_seed(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vrf_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GenerateRandomSeedResponse.vrf_seed)
}
inline void GenerateRandomSeedResponse::set_vrf_seed(const void* value, size_t size) {
  
  vrf_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GenerateRandomSeedResponse.vrf_seed)
}
inline ::std::string* GenerateRandomSeedResponse::mutable_vrf_seed() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GenerateRandomSeedResponse.vrf_seed)
  return vrf_seed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GenerateRandomSeedResponse::release_vrf_seed() {
  // @@protoc_insertion_point(field_release:rpcpb.GenerateRandomSeedResponse.vrf_seed)
  
  return vrf_seed_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenerateRandomSeedResponse::set_allocated_vrf_seed(::std::string* vrf_seed) {
  if (vrf_seed != NULL) {
    
  } else {
    
  }
  vrf_seed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vrf_seed);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GenerateRandomSeedResponse.vrf_seed)
}

// bytes vrf_proof = 2;
inline void GenerateRandomSeedResponse::clear_vrf_proof() {
  vrf_proof_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GenerateRandomSeedResponse::vrf_proof() const {
  // @@protoc_insertion_point(field_get:rpcpb.GenerateRandomSeedResponse.vrf_proof)
  return vrf_proof_.GetNoArena();
}
inline void GenerateRandomSeedResponse::set_vrf_proof(const ::std::string& value) {
  
  vrf_proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GenerateRandomSeedResponse.vrf_proof)
}
#if LANG_CXX11
inline void GenerateRandomSeedResponse::set_vrf_proof(::std::string&& value) {
  
  vrf_proof_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GenerateRandomSeedResponse.vrf_proof)
}
#endif
inline void GenerateRandomSeedResponse::set_vrf_proof(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vrf_proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GenerateRandomSeedResponse.vrf_proof)
}
inline void GenerateRandomSeedResponse::set_vrf_proof(const void* value, size_t size) {
  
  vrf_proof_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GenerateRandomSeedResponse.vrf_proof)
}
inline ::std::string* GenerateRandomSeedResponse::mutable_vrf_proof() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GenerateRandomSeedResponse.vrf_proof)
  return vrf_proof_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GenerateRandomSeedResponse::release_vrf_proof() {
  // @@protoc_insertion_point(field_release:rpcpb.GenerateRandomSeedResponse.vrf_proof)
  
  return vrf_proof_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GenerateRandomSeedResponse::set_allocated_vrf_proof(::std::string* vrf_proof) {
  if (vrf_proof != NULL) {
    
  } else {
    
  }
  vrf_proof_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vrf_proof);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GenerateRandomSeedResponse.vrf_proof)
}

// -------------------------------------------------------------------

// SignTransactionPassphraseRequest

// .rpcpb.TransactionRequest transaction = 1;
inline bool SignTransactionPassphraseRequest::has_transaction() const {
  return this != internal_default_instance() && transaction_ != NULL;
}
inline void SignTransactionPassphraseRequest::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) {
    delete transaction_;
  }
  transaction_ = NULL;
}
inline const ::rpcpb::TransactionRequest& SignTransactionPassphraseRequest::transaction() const {
  const ::rpcpb::TransactionRequest* p = transaction_;
  // @@protoc_insertion_point(field_get:rpcpb.SignTransactionPassphraseRequest.transaction)
  return p != NULL ? *p : *reinterpret_cast<const ::rpcpb::TransactionRequest*>(
      &::rpcpb::_TransactionRequest_default_instance_);
}
inline ::rpcpb::TransactionRequest* SignTransactionPassphraseRequest::release_transaction() {
  // @@protoc_insertion_point(field_release:rpcpb.SignTransactionPassphraseRequest.transaction)
  
  ::rpcpb::TransactionRequest* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline ::rpcpb::TransactionRequest* SignTransactionPassphraseRequest::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::rpcpb::TransactionRequest;
  }
  // @@protoc_insertion_point(field_mutable:rpcpb.SignTransactionPassphraseRequest.transaction)
  return transaction_;
}
inline void SignTransactionPassphraseRequest::set_allocated_transaction(::rpcpb::TransactionRequest* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transaction_;
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SignTransactionPassphraseRequest.transaction)
}

// string passphrase = 2;
inline void SignTransactionPassphraseRequest::clear_passphrase() {
  passphrase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignTransactionPassphraseRequest::passphrase() const {
  // @@protoc_insertion_point(field_get:rpcpb.SignTransactionPassphraseRequest.passphrase)
  return passphrase_.GetNoArena();
}
inline void SignTransactionPassphraseRequest::set_passphrase(const ::std::string& value) {
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SignTransactionPassphraseRequest.passphrase)
}
#if LANG_CXX11
inline void SignTransactionPassphraseRequest::set_passphrase(::std::string&& value) {
  
  passphrase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SignTransactionPassphraseRequest.passphrase)
}
#endif
inline void SignTransactionPassphraseRequest::set_passphrase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SignTransactionPassphraseRequest.passphrase)
}
inline void SignTransactionPassphraseRequest::set_passphrase(const char* value, size_t size) {
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SignTransactionPassphraseRequest.passphrase)
}
inline ::std::string* SignTransactionPassphraseRequest::mutable_passphrase() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SignTransactionPassphraseRequest.passphrase)
  return passphrase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignTransactionPassphraseRequest::release_passphrase() {
  // @@protoc_insertion_point(field_release:rpcpb.SignTransactionPassphraseRequest.passphrase)
  
  return passphrase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignTransactionPassphraseRequest::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase != NULL) {
    
  } else {
    
  }
  passphrase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passphrase);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SignTransactionPassphraseRequest.passphrase)
}

// -------------------------------------------------------------------

// SignTransactionPassphraseResponse

// bytes data = 1;
inline void SignTransactionPassphraseResponse::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignTransactionPassphraseResponse::data() const {
  // @@protoc_insertion_point(field_get:rpcpb.SignTransactionPassphraseResponse.data)
  return data_.GetNoArena();
}
inline void SignTransactionPassphraseResponse::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SignTransactionPassphraseResponse.data)
}
#if LANG_CXX11
inline void SignTransactionPassphraseResponse::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SignTransactionPassphraseResponse.data)
}
#endif
inline void SignTransactionPassphraseResponse::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SignTransactionPassphraseResponse.data)
}
inline void SignTransactionPassphraseResponse::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SignTransactionPassphraseResponse.data)
}
inline ::std::string* SignTransactionPassphraseResponse::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SignTransactionPassphraseResponse.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignTransactionPassphraseResponse::release_data() {
  // @@protoc_insertion_point(field_release:rpcpb.SignTransactionPassphraseResponse.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignTransactionPassphraseResponse::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SignTransactionPassphraseResponse.data)
}

// -------------------------------------------------------------------

// SendTransactionPassphraseRequest

// .rpcpb.TransactionRequest transaction = 1;
inline bool SendTransactionPassphraseRequest::has_transaction() const {
  return this != internal_default_instance() && transaction_ != NULL;
}
inline void SendTransactionPassphraseRequest::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) {
    delete transaction_;
  }
  transaction_ = NULL;
}
inline const ::rpcpb::TransactionRequest& SendTransactionPassphraseRequest::transaction() const {
  const ::rpcpb::TransactionRequest* p = transaction_;
  // @@protoc_insertion_point(field_get:rpcpb.SendTransactionPassphraseRequest.transaction)
  return p != NULL ? *p : *reinterpret_cast<const ::rpcpb::TransactionRequest*>(
      &::rpcpb::_TransactionRequest_default_instance_);
}
inline ::rpcpb::TransactionRequest* SendTransactionPassphraseRequest::release_transaction() {
  // @@protoc_insertion_point(field_release:rpcpb.SendTransactionPassphraseRequest.transaction)
  
  ::rpcpb::TransactionRequest* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline ::rpcpb::TransactionRequest* SendTransactionPassphraseRequest::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::rpcpb::TransactionRequest;
  }
  // @@protoc_insertion_point(field_mutable:rpcpb.SendTransactionPassphraseRequest.transaction)
  return transaction_;
}
inline void SendTransactionPassphraseRequest::set_allocated_transaction(::rpcpb::TransactionRequest* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transaction_;
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SendTransactionPassphraseRequest.transaction)
}

// string passphrase = 2;
inline void SendTransactionPassphraseRequest::clear_passphrase() {
  passphrase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendTransactionPassphraseRequest::passphrase() const {
  // @@protoc_insertion_point(field_get:rpcpb.SendTransactionPassphraseRequest.passphrase)
  return passphrase_.GetNoArena();
}
inline void SendTransactionPassphraseRequest::set_passphrase(const ::std::string& value) {
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.SendTransactionPassphraseRequest.passphrase)
}
#if LANG_CXX11
inline void SendTransactionPassphraseRequest::set_passphrase(::std::string&& value) {
  
  passphrase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.SendTransactionPassphraseRequest.passphrase)
}
#endif
inline void SendTransactionPassphraseRequest::set_passphrase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.SendTransactionPassphraseRequest.passphrase)
}
inline void SendTransactionPassphraseRequest::set_passphrase(const char* value, size_t size) {
  
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.SendTransactionPassphraseRequest.passphrase)
}
inline ::std::string* SendTransactionPassphraseRequest::mutable_passphrase() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.SendTransactionPassphraseRequest.passphrase)
  return passphrase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendTransactionPassphraseRequest::release_passphrase() {
  // @@protoc_insertion_point(field_release:rpcpb.SendTransactionPassphraseRequest.passphrase)
  
  return passphrase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendTransactionPassphraseRequest::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase != NULL) {
    
  } else {
    
  }
  passphrase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passphrase);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.SendTransactionPassphraseRequest.passphrase)
}

// -------------------------------------------------------------------

// GasPriceResponse

// string gas_price = 1;
inline void GasPriceResponse::clear_gas_price() {
  gas_price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GasPriceResponse::gas_price() const {
  // @@protoc_insertion_point(field_get:rpcpb.GasPriceResponse.gas_price)
  return gas_price_.GetNoArena();
}
inline void GasPriceResponse::set_gas_price(const ::std::string& value) {
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GasPriceResponse.gas_price)
}
#if LANG_CXX11
inline void GasPriceResponse::set_gas_price(::std::string&& value) {
  
  gas_price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GasPriceResponse.gas_price)
}
#endif
inline void GasPriceResponse::set_gas_price(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GasPriceResponse.gas_price)
}
inline void GasPriceResponse::set_gas_price(const char* value, size_t size) {
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GasPriceResponse.gas_price)
}
inline ::std::string* GasPriceResponse::mutable_gas_price() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GasPriceResponse.gas_price)
  return gas_price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GasPriceResponse::release_gas_price() {
  // @@protoc_insertion_point(field_release:rpcpb.GasPriceResponse.gas_price)
  
  return gas_price_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GasPriceResponse::set_allocated_gas_price(::std::string* gas_price) {
  if (gas_price != NULL) {
    
  } else {
    
  }
  gas_price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_price);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GasPriceResponse.gas_price)
}

// -------------------------------------------------------------------

// HashRequest

// string hash = 1;
inline void HashRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HashRequest::hash() const {
  // @@protoc_insertion_point(field_get:rpcpb.HashRequest.hash)
  return hash_.GetNoArena();
}
inline void HashRequest::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.HashRequest.hash)
}
#if LANG_CXX11
inline void HashRequest::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.HashRequest.hash)
}
#endif
inline void HashRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.HashRequest.hash)
}
inline void HashRequest::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.HashRequest.hash)
}
inline ::std::string* HashRequest::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.HashRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HashRequest::release_hash() {
  // @@protoc_insertion_point(field_release:rpcpb.HashRequest.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HashRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.HashRequest.hash)
}

// -------------------------------------------------------------------

// GasResponse

// string gas = 1;
inline void GasResponse::clear_gas() {
  gas_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GasResponse::gas() const {
  // @@protoc_insertion_point(field_get:rpcpb.GasResponse.gas)
  return gas_.GetNoArena();
}
inline void GasResponse::set_gas(const ::std::string& value) {
  
  gas_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GasResponse.gas)
}
#if LANG_CXX11
inline void GasResponse::set_gas(::std::string&& value) {
  
  gas_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GasResponse.gas)
}
#endif
inline void GasResponse::set_gas(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gas_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GasResponse.gas)
}
inline void GasResponse::set_gas(const char* value, size_t size) {
  
  gas_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GasResponse.gas)
}
inline ::std::string* GasResponse::mutable_gas() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GasResponse.gas)
  return gas_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GasResponse::release_gas() {
  // @@protoc_insertion_point(field_release:rpcpb.GasResponse.gas)
  
  return gas_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GasResponse::set_allocated_gas(::std::string* gas) {
  if (gas != NULL) {
    
  } else {
    
  }
  gas_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GasResponse.gas)
}

// string err = 2;
inline void GasResponse::clear_err() {
  err_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GasResponse::err() const {
  // @@protoc_insertion_point(field_get:rpcpb.GasResponse.err)
  return err_.GetNoArena();
}
inline void GasResponse::set_err(const ::std::string& value) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.GasResponse.err)
}
#if LANG_CXX11
inline void GasResponse::set_err(::std::string&& value) {
  
  err_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.GasResponse.err)
}
#endif
inline void GasResponse::set_err(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.GasResponse.err)
}
inline void GasResponse::set_err(const char* value, size_t size) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.GasResponse.err)
}
inline ::std::string* GasResponse::mutable_err() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.GasResponse.err)
  return err_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GasResponse::release_err() {
  // @@protoc_insertion_point(field_release:rpcpb.GasResponse.err)
  
  return err_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GasResponse::set_allocated_err(::std::string* err) {
  if (err != NULL) {
    
  } else {
    
  }
  err_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), err);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GasResponse.err)
}

// -------------------------------------------------------------------

// EventsResponse

// repeated .rpcpb.Event events = 1;
inline int EventsResponse::events_size() const {
  return events_.size();
}
inline void EventsResponse::clear_events() {
  events_.Clear();
}
inline const ::rpcpb::Event& EventsResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:rpcpb.EventsResponse.events)
  return events_.Get(index);
}
inline ::rpcpb::Event* EventsResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:rpcpb.EventsResponse.events)
  return events_.Mutable(index);
}
inline ::rpcpb::Event* EventsResponse::add_events() {
  // @@protoc_insertion_point(field_add:rpcpb.EventsResponse.events)
  return events_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::rpcpb::Event >*
EventsResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:rpcpb.EventsResponse.events)
  return &events_;
}
inline const ::google::protobuf::RepeatedPtrField< ::rpcpb::Event >&
EventsResponse::events() const {
  // @@protoc_insertion_point(field_list:rpcpb.EventsResponse.events)
  return events_;
}

// -------------------------------------------------------------------

// Event

// string topic = 1;
inline void Event::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::topic() const {
  // @@protoc_insertion_point(field_get:rpcpb.Event.topic)
  return topic_.GetNoArena();
}
inline void Event::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.Event.topic)
}
#if LANG_CXX11
inline void Event::set_topic(::std::string&& value) {
  
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.Event.topic)
}
#endif
inline void Event::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.Event.topic)
}
inline void Event::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.Event.topic)
}
inline ::std::string* Event::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.Event.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_topic() {
  // @@protoc_insertion_point(field_release:rpcpb.Event.topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.Event.topic)
}

// string data = 2;
inline void Event::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::data() const {
  // @@protoc_insertion_point(field_get:rpcpb.Event.data)
  return data_.GetNoArena();
}
inline void Event::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.Event.data)
}
#if LANG_CXX11
inline void Event::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.Event.data)
}
#endif
inline void Event::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.Event.data)
}
inline void Event::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.Event.data)
}
inline ::std::string* Event::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.Event.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_data() {
  // @@protoc_insertion_point(field_release:rpcpb.Event.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.Event.data)
}

// -------------------------------------------------------------------

// PprofRequest

// string listen = 1;
inline void PprofRequest::clear_listen() {
  listen_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PprofRequest::listen() const {
  // @@protoc_insertion_point(field_get:rpcpb.PprofRequest.listen)
  return listen_.GetNoArena();
}
inline void PprofRequest::set_listen(const ::std::string& value) {
  
  listen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.PprofRequest.listen)
}
#if LANG_CXX11
inline void PprofRequest::set_listen(::std::string&& value) {
  
  listen_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.PprofRequest.listen)
}
#endif
inline void PprofRequest::set_listen(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  listen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.PprofRequest.listen)
}
inline void PprofRequest::set_listen(const char* value, size_t size) {
  
  listen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.PprofRequest.listen)
}
inline ::std::string* PprofRequest::mutable_listen() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.PprofRequest.listen)
  return listen_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PprofRequest::release_listen() {
  // @@protoc_insertion_point(field_release:rpcpb.PprofRequest.listen)
  
  return listen_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PprofRequest::set_allocated_listen(::std::string* listen) {
  if (listen != NULL) {
    
  } else {
    
  }
  listen_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), listen);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.PprofRequest.listen)
}

// -------------------------------------------------------------------

// PprofResponse

// bool result = 1;
inline void PprofResponse::clear_result() {
  result_ = false;
}
inline bool PprofResponse::result() const {
  // @@protoc_insertion_point(field_get:rpcpb.PprofResponse.result)
  return result_;
}
inline void PprofResponse::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.PprofResponse.result)
}

// -------------------------------------------------------------------

// GetConfigResponse

// .nebletpb.Config config = 1;
inline bool GetConfigResponse::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline const ::nebletpb::Config& GetConfigResponse::config() const {
  const ::nebletpb::Config* p = config_;
  // @@protoc_insertion_point(field_get:rpcpb.GetConfigResponse.config)
  return p != NULL ? *p : *reinterpret_cast<const ::nebletpb::Config*>(
      &::nebletpb::_Config_default_instance_);
}
inline ::nebletpb::Config* GetConfigResponse::release_config() {
  // @@protoc_insertion_point(field_release:rpcpb.GetConfigResponse.config)
  
  ::nebletpb::Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::nebletpb::Config* GetConfigResponse::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::nebletpb::Config;
  }
  // @@protoc_insertion_point(field_mutable:rpcpb.GetConfigResponse.config)
  return config_;
}
inline void GetConfigResponse::set_allocated_config(::nebletpb::Config* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(config_);
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:rpcpb.GetConfigResponse.config)
}

// -------------------------------------------------------------------

// NVMDeployRequest

// string script_src = 1;
inline void NVMDeployRequest::clear_script_src() {
  script_src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NVMDeployRequest::script_src() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMDeployRequest.script_src)
  return script_src_.GetNoArena();
}
inline void NVMDeployRequest::set_script_src(const ::std::string& value) {
  
  script_src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NVMDeployRequest.script_src)
}
#if LANG_CXX11
inline void NVMDeployRequest::set_script_src(::std::string&& value) {
  
  script_src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NVMDeployRequest.script_src)
}
#endif
inline void NVMDeployRequest::set_script_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  script_src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NVMDeployRequest.script_src)
}
inline void NVMDeployRequest::set_script_src(const char* value, size_t size) {
  
  script_src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NVMDeployRequest.script_src)
}
inline ::std::string* NVMDeployRequest::mutable_script_src() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NVMDeployRequest.script_src)
  return script_src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NVMDeployRequest::release_script_src() {
  // @@protoc_insertion_point(field_release:rpcpb.NVMDeployRequest.script_src)
  
  return script_src_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NVMDeployRequest::set_allocated_script_src(::std::string* script_src) {
  if (script_src != NULL) {
    
  } else {
    
  }
  script_src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script_src);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NVMDeployRequest.script_src)
}

// string from_addr = 2;
inline void NVMDeployRequest::clear_from_addr() {
  from_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NVMDeployRequest::from_addr() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMDeployRequest.from_addr)
  return from_addr_.GetNoArena();
}
inline void NVMDeployRequest::set_from_addr(const ::std::string& value) {
  
  from_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NVMDeployRequest.from_addr)
}
#if LANG_CXX11
inline void NVMDeployRequest::set_from_addr(::std::string&& value) {
  
  from_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NVMDeployRequest.from_addr)
}
#endif
inline void NVMDeployRequest::set_from_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  from_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NVMDeployRequest.from_addr)
}
inline void NVMDeployRequest::set_from_addr(const char* value, size_t size) {
  
  from_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NVMDeployRequest.from_addr)
}
inline ::std::string* NVMDeployRequest::mutable_from_addr() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NVMDeployRequest.from_addr)
  return from_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NVMDeployRequest::release_from_addr() {
  // @@protoc_insertion_point(field_release:rpcpb.NVMDeployRequest.from_addr)
  
  return from_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NVMDeployRequest::set_allocated_from_addr(::std::string* from_addr) {
  if (from_addr != NULL) {
    
  } else {
    
  }
  from_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_addr);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NVMDeployRequest.from_addr)
}

// int64 block_height = 3;
inline void NVMDeployRequest::clear_block_height() {
  block_height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NVMDeployRequest::block_height() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMDeployRequest.block_height)
  return block_height_;
}
inline void NVMDeployRequest::set_block_height(::google::protobuf::int64 value) {
  
  block_height_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.NVMDeployRequest.block_height)
}

// string type = 4;
inline void NVMDeployRequest::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NVMDeployRequest::type() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMDeployRequest.type)
  return type_.GetNoArena();
}
inline void NVMDeployRequest::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NVMDeployRequest.type)
}
#if LANG_CXX11
inline void NVMDeployRequest::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NVMDeployRequest.type)
}
#endif
inline void NVMDeployRequest::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NVMDeployRequest.type)
}
inline void NVMDeployRequest::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NVMDeployRequest.type)
}
inline ::std::string* NVMDeployRequest::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NVMDeployRequest.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NVMDeployRequest::release_type() {
  // @@protoc_insertion_point(field_release:rpcpb.NVMDeployRequest.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NVMDeployRequest::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NVMDeployRequest.type)
}

// -------------------------------------------------------------------

// NVMDataRequest

// string request_type = 1;
inline void NVMDataRequest::clear_request_type() {
  request_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NVMDataRequest::request_type() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMDataRequest.request_type)
  return request_type_.GetNoArena();
}
inline void NVMDataRequest::set_request_type(const ::std::string& value) {
  
  request_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NVMDataRequest.request_type)
}
#if LANG_CXX11
inline void NVMDataRequest::set_request_type(::std::string&& value) {
  
  request_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NVMDataRequest.request_type)
}
#endif
inline void NVMDataRequest::set_request_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  request_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NVMDataRequest.request_type)
}
inline void NVMDataRequest::set_request_type(const char* value, size_t size) {
  
  request_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NVMDataRequest.request_type)
}
inline ::std::string* NVMDataRequest::mutable_request_type() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NVMDataRequest.request_type)
  return request_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NVMDataRequest::release_request_type() {
  // @@protoc_insertion_point(field_release:rpcpb.NVMDataRequest.request_type)
  
  return request_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NVMDataRequest::set_allocated_request_type(::std::string* request_type) {
  if (request_type != NULL) {
    
  } else {
    
  }
  request_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_type);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NVMDataRequest.request_type)
}

// string script_src = 2;
inline void NVMDataRequest::clear_script_src() {
  script_src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NVMDataRequest::script_src() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMDataRequest.script_src)
  return script_src_.GetNoArena();
}
inline void NVMDataRequest::set_script_src(const ::std::string& value) {
  
  script_src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NVMDataRequest.script_src)
}
#if LANG_CXX11
inline void NVMDataRequest::set_script_src(::std::string&& value) {
  
  script_src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NVMDataRequest.script_src)
}
#endif
inline void NVMDataRequest::set_script_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  script_src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NVMDataRequest.script_src)
}
inline void NVMDataRequest::set_script_src(const char* value, size_t size) {
  
  script_src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NVMDataRequest.script_src)
}
inline ::std::string* NVMDataRequest::mutable_script_src() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NVMDataRequest.script_src)
  return script_src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NVMDataRequest::release_script_src() {
  // @@protoc_insertion_point(field_release:rpcpb.NVMDataRequest.script_src)
  
  return script_src_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NVMDataRequest::set_allocated_script_src(::std::string* script_src) {
  if (script_src != NULL) {
    
  } else {
    
  }
  script_src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script_src);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NVMDataRequest.script_src)
}

// string function_name = 3;
inline void NVMDataRequest::clear_function_name() {
  function_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NVMDataRequest::function_name() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMDataRequest.function_name)
  return function_name_.GetNoArena();
}
inline void NVMDataRequest::set_function_name(const ::std::string& value) {
  
  function_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NVMDataRequest.function_name)
}
#if LANG_CXX11
inline void NVMDataRequest::set_function_name(::std::string&& value) {
  
  function_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NVMDataRequest.function_name)
}
#endif
inline void NVMDataRequest::set_function_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  function_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NVMDataRequest.function_name)
}
inline void NVMDataRequest::set_function_name(const char* value, size_t size) {
  
  function_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NVMDataRequest.function_name)
}
inline ::std::string* NVMDataRequest::mutable_function_name() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NVMDataRequest.function_name)
  return function_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NVMDataRequest::release_function_name() {
  // @@protoc_insertion_point(field_release:rpcpb.NVMDataRequest.function_name)
  
  return function_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NVMDataRequest::set_allocated_function_name(::std::string* function_name) {
  if (function_name != NULL) {
    
  } else {
    
  }
  function_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), function_name);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NVMDataRequest.function_name)
}

// string contract_addr = 4;
inline void NVMDataRequest::clear_contract_addr() {
  contract_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NVMDataRequest::contract_addr() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMDataRequest.contract_addr)
  return contract_addr_.GetNoArena();
}
inline void NVMDataRequest::set_contract_addr(const ::std::string& value) {
  
  contract_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NVMDataRequest.contract_addr)
}
#if LANG_CXX11
inline void NVMDataRequest::set_contract_addr(::std::string&& value) {
  
  contract_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NVMDataRequest.contract_addr)
}
#endif
inline void NVMDataRequest::set_contract_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contract_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NVMDataRequest.contract_addr)
}
inline void NVMDataRequest::set_contract_addr(const char* value, size_t size) {
  
  contract_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NVMDataRequest.contract_addr)
}
inline ::std::string* NVMDataRequest::mutable_contract_addr() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NVMDataRequest.contract_addr)
  return contract_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NVMDataRequest::release_contract_addr() {
  // @@protoc_insertion_point(field_release:rpcpb.NVMDataRequest.contract_addr)
  
  return contract_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NVMDataRequest::set_allocated_contract_addr(::std::string* contract_addr) {
  if (contract_addr != NULL) {
    
  } else {
    
  }
  contract_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract_addr);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NVMDataRequest.contract_addr)
}

// string extra_data = 5;
inline void NVMDataRequest::clear_extra_data() {
  extra_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NVMDataRequest::extra_data() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMDataRequest.extra_data)
  return extra_data_.GetNoArena();
}
inline void NVMDataRequest::set_extra_data(const ::std::string& value) {
  
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NVMDataRequest.extra_data)
}
#if LANG_CXX11
inline void NVMDataRequest::set_extra_data(::std::string&& value) {
  
  extra_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NVMDataRequest.extra_data)
}
#endif
inline void NVMDataRequest::set_extra_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NVMDataRequest.extra_data)
}
inline void NVMDataRequest::set_extra_data(const char* value, size_t size) {
  
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NVMDataRequest.extra_data)
}
inline ::std::string* NVMDataRequest::mutable_extra_data() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NVMDataRequest.extra_data)
  return extra_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NVMDataRequest::release_extra_data() {
  // @@protoc_insertion_point(field_release:rpcpb.NVMDataRequest.extra_data)
  
  return extra_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NVMDataRequest::set_allocated_extra_data(::std::string* extra_data) {
  if (extra_data != NULL) {
    
  } else {
    
  }
  extra_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra_data);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NVMDataRequest.extra_data)
}

// -------------------------------------------------------------------

// NVMResponse

// int32 result = 1;
inline void NVMResponse::clear_result() {
  result_ = 0;
}
inline ::google::protobuf::int32 NVMResponse::result() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMResponse.result)
  return result_;
}
inline void NVMResponse::set_result(::google::protobuf::int32 value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:rpcpb.NVMResponse.result)
}

// string msg = 2;
inline void NVMResponse::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NVMResponse::msg() const {
  // @@protoc_insertion_point(field_get:rpcpb.NVMResponse.msg)
  return msg_.GetNoArena();
}
inline void NVMResponse::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rpcpb.NVMResponse.msg)
}
#if LANG_CXX11
inline void NVMResponse::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rpcpb.NVMResponse.msg)
}
#endif
inline void NVMResponse::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rpcpb.NVMResponse.msg)
}
inline void NVMResponse::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rpcpb.NVMResponse.msg)
}
inline ::std::string* NVMResponse::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:rpcpb.NVMResponse.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NVMResponse::release_msg() {
  // @@protoc_insertion_point(field_release:rpcpb.NVMResponse.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NVMResponse::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:rpcpb.NVMResponse.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpcpb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rpc_2eproto__INCLUDED
